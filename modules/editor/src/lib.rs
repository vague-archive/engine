use game_module_macro::{system, system_once, ResourceWithoutSerialize};
use void_public::{
    event as events_generated, input::InputState, Aspect, ComponentId, EcsType, EventReader,
    EventWriter, Resource,
};
pub mod event {
    #![allow(clippy::all, clippy::pedantic, warnings, unused, unused_imports)]
    include!(concat!(env!("OUT_DIR"), "/ipc_generated.rs"));
}
use event::{
    Closed, MessageFromRemote, MessageToRemote, Opened, PortListen, PortListenArgs,
    PortListenResult,
};

pub mod editor_messages {
    #![allow(clippy::all, clippy::pedantic, warnings, unused, unused_imports)]
    include!(concat!(env!("OUT_DIR"), "/editor_messages_generated.rs"));

    // Re-export everything from the inner editor_messages module.
    pub use self::editor_messages::*;
}

pub mod aspect_ratio;
pub mod handlers;

pub mod ffi {
    #![allow(clippy::all, clippy::pedantic, warnings, unused, unused_imports)]
    use super::*;

    // A collection of C repr versions of the resources and systems in this file.
    // Generated by "../build.rs".
    include!(concat!(env!("OUT_DIR"), "/ffi.rs"));
}

const EDITOR_PORT: u16 = 9002;
const EDITOR_USER_ID: &str = env!("CARGO_PKG_NAME");

/// State for the editor agent and its active connections.
#[derive(Default, ResourceWithoutSerialize)]
pub struct AgentState {
    // This may more naturally be a set, such as a `HashSet`, but the number of
    // values is expected to be exceedingly low (often one entry).
    pub active_connections: Vec<u16>,
    pub aspect_ratio: AspectRatio,
}

/// Contains the current aspect ratio information.
#[derive(Default, Clone, Copy)]
pub struct AspectRatio {
    pub width: f32,
    pub height: f32,
}

pub fn record_connection_opened(agent_state: &mut AgentState, channel: u16) {
    if !agent_state.active_connections.contains(&channel) {
        agent_state.active_connections.push(channel);
    }
}

pub fn record_connection_closed(agent_state: &mut AgentState, channel: u16) {
    agent_state.active_connections.retain(|c| *c != channel);
}

// EventWriter and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system_once]
fn init_editor(port_listen_writer: EventWriter<PortListen<'_>>) {
    log::info!(
        "Editor module {} listening on port {}",
        EDITOR_USER_ID,
        EDITOR_PORT
    );

    port_listen_writer.write_builder(|builder| {
        let user_id = Some(builder.create_string(EDITOR_USER_ID));
        PortListen::create(
            builder,
            &PortListenArgs {
                port: EDITOR_PORT,
                user_id,
            },
        )
    });
}

// EventWriter and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system]
fn handle_port_listen_result_events(reader: EventReader<PortListenResult<'_>>) {
    for event in &reader {
        log::trace!("Editor module: received event {:?}", event);
    }
}

// EventWriter and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system]
fn handle_opened_events(
    agent_state: &mut AgentState,
    reader: EventReader<Opened<'_>>,
    writer: EventWriter<MessageToRemote<'_>>,
) {
    for event in &reader {
        log::trace!("Editor module: received event {:?}", event);
        if event.user_id() == Some(EDITOR_USER_ID) {
            let channel = event.channel();
            record_connection_opened(agent_state, channel);

            aspect_ratio::send_aspect_ratio(
                channel,
                &writer,
                agent_state.aspect_ratio.width,
                agent_state.aspect_ratio.height,
            );
        }
    }
}

// EventWriter and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system]
fn handle_closed_events(agent_state: &mut AgentState, reader: EventReader<Closed>) {
    for event in &reader {
        log::trace!("Editor module: received event {:?}", event);
        let closed = event.channel();
        record_connection_closed(agent_state, closed);
    }
}

/// Process messages from remote connections through the IPC system.
///
/// This system receives messages from remote clients, parses them using
/// `FlatBuffers`, and routes them to the appropriate handlers based on
/// message type.
// EventWriter and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system]
fn handle_message_events(
    agent_state: &mut AgentState,
    reader: EventReader<MessageFromRemote<'_>>,
    writer: EventWriter<MessageToRemote<'_>>,
) {
    for event in &reader {
        log::trace!("Editor module: received event {:?}", event);
        let channel = event.channel();
        if agent_state.active_connections.contains(&channel) {
            // `content` is the body of the message from the remote end of the connection.
            if let Some(content) = event.content() {
                let bytes = content.bytes();

                // Process the message using the structured handler.
                if let Some(response) = handlers::process_message(bytes) {
                    handlers::responses::send_editor_response(channel, &response, &writer);
                }
            } else {
                log::warn!("Received event with no content");
            }
        }
    }
}

/// System that monitors aspect ratio changes and broadcasts updates.
// EventWriter and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system]
fn broadcast_aspect_ratio(
    agent_state: &mut AgentState,
    aspect: &Aspect,
    writer: EventWriter<MessageToRemote<'_>>,
) {
    let width = aspect.width;
    let height = aspect.height;

    // Skip if no changes.
    if width == agent_state.aspect_ratio.width && height == agent_state.aspect_ratio.height {
        return;
    }

    // Update stored aspect ratio.
    agent_state.aspect_ratio.width = width;
    agent_state.aspect_ratio.height = height;

    // Send updates to all active connections.
    for &channel in &agent_state.active_connections {
        handlers::aspect_ratio_handler::send_aspect_ratio(channel, width, height, &writer);
    }
}

/// Process input messages and update the input state.
/// `EventWriter` and Reader must be passed by value.
#[allow(clippy::needless_pass_by_value)]
#[system]
fn handle_input_message_events(
    agent_state: &mut AgentState,
    input_state: &mut InputState,
    reader: EventReader<MessageFromRemote<'_>>,
    writer: EventWriter<MessageToRemote<'_>>,
) {
    for event in &reader {
        let channel = event.channel();

        if agent_state.active_connections.contains(&channel) {
            if let Some(content) = event.content() {
                if let Some(response) =
                    handlers::handle_if_input_message::process(content.bytes(), input_state)
                {
                    handlers::responses::send_editor_response(channel, &response, &writer);
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_connection_lifecycle() {
        let mut agent_state = AgentState::default();

        assert_eq!(agent_state.active_connections.len(), 0);

        record_connection_opened(&mut agent_state, 1);
        assert_eq!(agent_state.active_connections.len(), 1);
        assert!(agent_state.active_connections.contains(&1));

        record_connection_opened(&mut agent_state, 2);
        assert_eq!(agent_state.active_connections.len(), 2);
        assert!(agent_state.active_connections.contains(&1));
        assert!(agent_state.active_connections.contains(&2));

        record_connection_closed(&mut agent_state, 1);
        assert_eq!(agent_state.active_connections.len(), 1);
        assert!(!agent_state.active_connections.contains(&1));
        assert!(agent_state.active_connections.contains(&2));

        // Close a non-existent connection (channel 3) - should not cause errors
        // or close wrong connections
        record_connection_closed(&mut agent_state, 3);
        assert_eq!(agent_state.active_connections.len(), 1);
        assert!(agent_state.active_connections.contains(&2));
    }
}
