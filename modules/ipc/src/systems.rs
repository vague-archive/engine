//! Systems (in ECS) which support Inter Process Communication (IPC).
//!
//! See [`./lib.rs`] and [`../README.md`] for documentation.

// Required for `EventReader` and `EventWriter`.
#![allow(clippy::needless_pass_by_value)]

// TODO(https://github.com/vaguevoid/engine/issues/316): Consider replacing hash map.
use std::{
    collections::{hash_map::Entry, HashMap},
    sync::{
        mpsc::{self, Receiver, Sender, TryRecvError},
        Mutex,
    },
};

use game_module_macro::{system, ResourceWithoutSerialize};
use void_public::{ComponentId, EcsType, EventReader, EventWriter, Resource};

use crate::{
    event::{
        Close, Closed, MessageFromRemote, MessageFromRemoteArgs, MessageToRemote, Opened,
        OpenedArgs, PortIgnore, PortIgnored, PortIgnoredArgs, PortListen, PortListenResult,
        PortListenResultArgs, PortListenResultCode,
    },
    websocket_ipc::{Channel, IpcChannelRecord, IpcListenerRecord, Port, ToChannel, ToHostSystem},
};

pub mod ffi {
    #![allow(clippy::all, clippy::pedantic, warnings, unused, unused_imports)]
    use super::*;
    use crate::systems;

    // A collection of C repr versions of the resources and systems in this file.
    // Generated by "../build.rs".
    include!(concat!(env!("OUT_DIR"), "/ffi.rs"));
}

/// The overall state of the IPC Host Module.
#[derive(ResourceWithoutSerialize)]
struct IpcState {
    /// Lookup for ports being listened to.
    ports: HashMap<Port, IpcListenerRecord>,

    /// Lookup for connected channel information.
    channels: HashMap<Channel, IpcChannelRecord>,

    /// This is cloned into child threads (no `.send()` called from this thread).
    to_host_system: Sender<ToHostSystem>,

    /// Incoming messages from the web (or at least the web-facing threads).
    /// This has a mutex because a Resource requires the Sync trait and Mutex is
    /// a way to get that.
    from_ipc_threads: Mutex<Receiver<ToHostSystem>>,
}

impl Default for IpcState {
    fn default() -> Self {
        let (to_host_system, from_ipc_threads) = mpsc::channel::<ToHostSystem>();
        // This is exempt from the 'no mutex in modules' rule because this is an extension.
        let from_ipc_threads = Mutex::new(from_ipc_threads);
        Self {
            ports: HashMap::new(),
            channels: HashMap::new(),
            to_host_system,
            from_ipc_threads,
        }
    }
}

/// Process messages coming from WebSocket threads.
///
/// Messages are passed along to IPC Agent Module as appropriate.
#[system]
fn websocket_messages_from_remotes(
    ipc_state: &mut IpcState,
    closed_writer: EventWriter<Closed>,
    opened_writer: EventWriter<Opened<'_>>,
    message_writer: EventWriter<MessageFromRemote<'_>>,
    port_ignored_writer: EventWriter<PortIgnored<'_>>,
    port_listen_result_writer: EventWriter<PortListenResult<'_>>,
) {
    log::trace!("websocket_messages begin");
    loop {
        let from_ipc_threads = ipc_state.from_ipc_threads.get_mut().unwrap();
        match from_ipc_threads.try_recv() {
            Err(TryRecvError::Disconnected | TryRecvError::Empty) => break,
            Ok(to_host_system) => match to_host_system {
                ToHostSystem::Message { channel, content } => {
                    message_writer.write_builder(|builder| {
                        let content_offset = builder.create_vector(&content);
                        MessageFromRemote::create(
                            builder,
                            &MessageFromRemoteArgs {
                                channel,
                                content: Some(content_offset),
                            },
                        )
                    });
                }
                ToHostSystem::ListenFailed { port, user_id } => {
                    port_listen_result_writer.write_builder(|builder| {
                        let user_id = Some(builder.create_string(&user_id));
                        PortListenResult::create(
                            builder,
                            &PortListenResultArgs {
                                port,
                                user_id,
                                result: PortListenResultCode::GeneralFailure,
                            },
                        )
                    });
                }
                ToHostSystem::PortIgnored { port } => {
                    if let Some(info) = ipc_state.ports.remove(&port) {
                        port_ignored_writer.write_builder(|builder| {
                            let user_id = Some(builder.create_string(info.user_id()));
                            PortIgnored::create(builder, &PortIgnoredArgs { port, user_id })
                        });
                    }
                }
                ToHostSystem::Opened(ipc_channel) => {
                    if ipc_state.channels.contains_key(&ipc_channel.channel()) {
                        log::info!(
                            "IPC Error: new channel for same key {}",
                            ipc_channel.channel()
                        );
                    }
                    if ipc_state.ports.contains_key(&ipc_channel.port()) {
                        // This might not be an actual error.
                        log::trace!(
                            "IPC Oddity: new channel for ignored port {}",
                            ipc_channel.port()
                        );
                    }
                    let port = ipc_channel.port();
                    let user_id = ipc_channel.user_id().to_string();
                    let channel = ipc_channel.channel();
                    ipc_state
                        .channels
                        .insert(ipc_channel.channel(), ipc_channel);
                    opened_writer.write_builder(|builder| {
                        let user_id = Some(builder.create_string(&user_id));
                        Opened::create(
                            builder,
                            &OpenedArgs {
                                port,
                                user_id,
                                channel,
                            },
                        )
                    });
                }
                ToHostSystem::Closed { channel } => {
                    if ipc_state.channels.remove(&channel).is_some() {
                        closed_writer.write(Closed::new(channel));
                    } else {
                        log::info!("IPC Host: removing channel for missing key {}", channel);
                    }
                }
            },
        }
    }
}

/// Handle events coming from IPC Agent Module systems.
#[system]
fn handle_port_listen_events(
    reader: EventReader<PortListen<'_>>,
    writer: EventWriter<PortListenResult<'_>>,
    ipc_state: &mut IpcState,
) {
    for event in &reader {
        log::trace!("IPC Host: received event {:?}", event);
        let port = event.port();
        let user_id = event.user_id().unwrap();
        log::trace!("Adding {port} into ipc_state.ports");
        let result = if let Entry::Vacant(vacant_entry) = ipc_state.ports.entry(port) {
            let record = IpcListenerRecord::new(port, user_id, ipc_state.to_host_system.clone());
            vacant_entry.insert(record);
            PortListenResultCode::Success
        } else {
            PortListenResultCode::InUseFailure
        };
        writer.write_builder(|builder| {
            let user_id = Some(builder.create_string(user_id));
            PortListenResult::create(
                builder,
                &PortListenResultArgs {
                    port,
                    user_id,
                    result,
                },
            )
        });
    }
}

/// Handle events coming from IPC Agent Module systems.
#[system]
fn handle_message_to_remote_events(
    ipc_state: &mut IpcState,
    reader: EventReader<MessageToRemote<'_>>,
) {
    for event in &reader {
        log::trace!("IPC Host: received event {:?}", event);
        let channel = event.channel();
        if let Some(info) = ipc_state.channels.get(&channel) {
            let content = event.content().unwrap().bytes();
            let _ = info.to_remote().send(ToChannel::Message(content.into()));
        } else {
            log::info!("IPC Host: channel info not found {channel}");
        }
    }
}

/// Close (disconnect) from a client.
///
/// Handle events coming from IPC Agent Module systems.
/// The port listening is unaffected by this call.
#[system]
fn handle_close_events(reader: EventReader<Close>, ipc_state: &mut IpcState) {
    for event in &reader {
        log::trace!("IPC Host: received event {:?}", event);
        let channel = event.channel();
        ipc_state.channels.remove(&channel);
    }
}

/// Handle events coming from IPC Agent Module systems.
#[system]
fn handle_port_ignore_events(
    reader: EventReader<PortIgnore<'_>>,
    writer: EventWriter<PortIgnored<'_>>,
    ipc_state: &mut IpcState,
) {
    for event in &reader {
        log::trace!("IPC Host: received event {:?}", event);
        let port = event.port();
        let _ = ipc_state.ports.remove(&port);

        // The response is more of an acknowledgement than a statement of success.
        let user_id = event.user_id().unwrap();
        writer.write_builder(|builder| {
            let user_id = Some(builder.create_string(user_id));
            PortIgnored::create(builder, &PortIgnoredArgs { port, user_id })
        });
    }
}

#[cfg(test)]
mod tests {
    // TODO(https://github.com/vaguevoid/engine/issues/375): Add tests for the systems above.
}
