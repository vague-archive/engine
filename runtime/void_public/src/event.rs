// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::{cmp::Ordering, mem};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

// struct Vec2, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec2(pub [u8; 8]);
impl Default for Vec2 {
    fn default() -> Self {
        Self([0; 8])
    }
}
impl core::fmt::Debug for Vec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vec2")
            .field("x", &self.x())
            .field("y", &self.y())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec2 {}
impl<'a> flatbuffers::Follow<'a> for Vec2 {
    type Inner = &'a Vec2;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vec2>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec2 {
    type Inner = &'a Vec2;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vec2>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vec2 {
    type Output = Vec2;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec2 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec2 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vec2 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: f32, y: f32) -> Self {
        let mut s = Self([0; 8]);
        s.set_x(x);
        s.set_y(y);
        s
    }

    pub const fn get_fully_qualified_name() -> &'static str {
        "Vec2"
    }

    pub fn x(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn unpack(&self) -> Vec2T {
        Vec2T {
            x: self.x(),
            y: self.y(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec2T {
    pub x: f32,
    pub y: f32,
}
impl Vec2T {
    pub fn pack(&self) -> Vec2 {
        Vec2::new(self.x, self.y)
    }
}

// struct Vec3, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec3(pub [u8; 12]);
impl Default for Vec3 {
    fn default() -> Self {
        Self([0; 12])
    }
}
impl core::fmt::Debug for Vec3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vec3")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
impl<'a> flatbuffers::Follow<'a> for Vec3 {
    type Inner = &'a Vec3;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vec3>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
    type Inner = &'a Vec3;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vec3 {
    type Output = Vec3;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec3 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vec3 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: f32, y: f32, z: f32) -> Self {
        let mut s = Self([0; 12]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s
    }

    pub const fn get_fully_qualified_name() -> &'static str {
        "Vec3"
    }

    pub fn x(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn unpack(&self) -> Vec3T {
        Vec3T {
            x: self.x(),
            y: self.y(),
            z: self.z(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Vec3T {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl Vec3T {
    pub fn pack(&self) -> Vec3 {
        Vec3::new(self.x, self.y, self.z)
    }
}

// struct Mat3x3, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Mat3x3(pub [u8; 36]);
impl Default for Mat3x3 {
    fn default() -> Self {
        Self([0; 36])
    }
}
impl core::fmt::Debug for Mat3x3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mat3x3").field("m", &self.m()).finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Mat3x3 {}
impl<'a> flatbuffers::Follow<'a> for Mat3x3 {
    type Inner = &'a Mat3x3;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Mat3x3>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Mat3x3 {
    type Inner = &'a Mat3x3;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Mat3x3>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Mat3x3 {
    type Output = Mat3x3;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Mat3x3 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Mat3x3 {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Mat3x3 {
    #[allow(clippy::too_many_arguments)]
    pub fn new(m: &[f32; 9]) -> Self {
        let mut s = Self([0; 36]);
        s.set_m(m);
        s
    }

    pub const fn get_fully_qualified_name() -> &'static str {
        "Mat3x3"
    }

    pub fn m(&'a self) -> flatbuffers::Array<'a, f32, 9> {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::Array::follow(&self.0, 0) }
    }

    pub fn set_m(&mut self, items: &[f32; 9]) {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
    }

    pub fn unpack(&self) -> Mat3x3T {
        Mat3x3T { m: self.m().into() }
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct Mat3x3T {
    pub m: [f32; 9],
}
impl Mat3x3T {
    pub fn pack(&self) -> Mat3x3 {
        Mat3x3::new(&self.m)
    }
}

// struct Transform, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Transform(pub [u8; 40]);
impl Default for Transform {
    fn default() -> Self {
        Self([0; 40])
    }
}
impl core::fmt::Debug for Transform {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Transform")
            .field("position", &self.position())
            .field("scale", &self.scale())
            .field("skew", &self.skew())
            .field("pivot", &self.pivot())
            .field("rotation", &self.rotation())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
impl<'a> flatbuffers::Follow<'a> for Transform {
    type Inner = &'a Transform;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Transform>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Transform {
    type Inner = &'a Transform;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Transform>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src =
            ::core::slice::from_raw_parts(self as *const Transform as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Transform {
    #[allow(clippy::too_many_arguments)]
    pub fn new(position: &Vec3, scale: &Vec2, skew: &Vec2, pivot: &Vec2, rotation: f32) -> Self {
        let mut s = Self([0; 40]);
        s.set_position(position);
        s.set_scale(scale);
        s.set_skew(skew);
        s.set_pivot(pivot);
        s.set_rotation(rotation);
        s
    }

    pub const fn get_fully_qualified_name() -> &'static str {
        "Transform"
    }

    pub fn position(&self) -> &Vec3 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[0..].as_ptr() as *const Vec3) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_position(&mut self, x: &Vec3) {
        self.0[0..0 + 12].copy_from_slice(&x.0)
    }

    pub fn scale(&self) -> &Vec2 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[12..].as_ptr() as *const Vec2) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_scale(&mut self, x: &Vec2) {
        self.0[12..12 + 8].copy_from_slice(&x.0)
    }

    pub fn skew(&self) -> &Vec2 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[20..].as_ptr() as *const Vec2) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_skew(&mut self, x: &Vec2) {
        self.0[20..20 + 8].copy_from_slice(&x.0)
    }

    /// 0 -> 1 relative to top left.
    pub fn pivot(&self) -> &Vec2 {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid struct in this slot
        unsafe { &*(self.0[28..].as_ptr() as *const Vec2) }
    }

    #[allow(clippy::identity_op)]
    pub fn set_pivot(&mut self, x: &Vec2) {
        self.0[28..28 + 8].copy_from_slice(&x.0)
    }

    /// Radians.
    pub fn rotation(&self) -> f32 {
        let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[36..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_rotation(&mut self, x: f32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[36..].as_mut_ptr(),
                core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn unpack(&self) -> TransformT {
        TransformT {
            position: self.position().unpack(),
            scale: self.scale().unpack(),
            skew: self.skew().unpack(),
            pivot: self.pivot().unpack(),
            rotation: self.rotation(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransformT {
    pub position: Vec3T,
    pub scale: Vec2T,
    pub skew: Vec2T,
    pub pivot: Vec2T,
    pub rotation: f32,
}
impl TransformT {
    pub fn pack(&self) -> Transform {
        Transform::new(
            &self.position.pack(),
            &self.scale.pack(),
            &self.skew.pack(),
            &self.pivot.pack(),
            self.rotation,
        )
    }
}

#[allow(unused_imports, dead_code)]
pub mod physics {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    // struct BoxCollision, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct BoxCollision(pub [u8; 16]);
    impl Default for BoxCollision {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for BoxCollision {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("BoxCollision")
                .field("entities", &self.entities())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for BoxCollision {}
    impl<'a> flatbuffers::Follow<'a> for BoxCollision {
        type Inner = &'a BoxCollision;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a BoxCollision>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a BoxCollision {
        type Inner = &'a BoxCollision;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<BoxCollision>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for BoxCollision {
        type Output = BoxCollision;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const BoxCollision as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for BoxCollision {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> BoxCollision {
        #[allow(clippy::too_many_arguments)]
        pub fn new(entities: &[u64; 2]) -> Self {
            let mut s = Self([0; 16]);
            s.set_entities(entities);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Physics.BoxCollision"
        }

        pub fn entities(&'a self) -> flatbuffers::Array<'a, u64, 2> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_entities(&mut self, items: &[u64; 2]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }

        pub fn unpack(&self) -> BoxCollisionT {
            BoxCollisionT {
                entities: self.entities().into(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct BoxCollisionT {
        pub entities: [u64; 2],
    }
    impl BoxCollisionT {
        pub fn pack(&self) -> BoxCollision {
            BoxCollision::new(&self.entities)
        }
    }

    // struct CircleCollision, aligned to 8
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct CircleCollision(pub [u8; 16]);
    impl Default for CircleCollision {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for CircleCollision {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("CircleCollision")
                .field("entities", &self.entities())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for CircleCollision {}
    impl<'a> flatbuffers::Follow<'a> for CircleCollision {
        type Inner = &'a CircleCollision;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a CircleCollision>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a CircleCollision {
        type Inner = &'a CircleCollision;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<CircleCollision>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for CircleCollision {
        type Output = CircleCollision;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const CircleCollision as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for CircleCollision {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> CircleCollision {
        #[allow(clippy::too_many_arguments)]
        pub fn new(entities: &[u64; 2]) -> Self {
            let mut s = Self([0; 16]);
            s.set_entities(entities);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Physics.CircleCollision"
        }

        pub fn entities(&'a self) -> flatbuffers::Array<'a, u64, 2> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_entities(&mut self, items: &[u64; 2]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }

        pub fn unpack(&self) -> CircleCollisionT {
            CircleCollisionT {
                entities: self.entities().into(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct CircleCollisionT {
        pub entities: [u64; 2],
    }
    impl CircleCollisionT {
        pub fn pack(&self) -> CircleCollision {
            CircleCollision::new(&self.entities)
        }
    }
} // pub mod Physics

#[allow(unused_imports, dead_code)]
pub mod graphics {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TEXT_MESSAGE_FORMAT_TYPE: i32 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TEXT_MESSAGE_FORMAT_TYPE: i32 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TEXT_MESSAGE_FORMAT_TYPE: [TextMessageFormatType; 4] = [
        TextMessageFormatType::Json,
        TextMessageFormatType::Toml,
        TextMessageFormatType::Csv,
        TextMessageFormatType::Text,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TextMessageFormatType(pub i32);
    #[allow(non_upper_case_globals)]
    impl TextMessageFormatType {
        pub const Json: Self = Self(0);
        pub const Toml: Self = Self(1);
        pub const Csv: Self = Self(2);
        pub const Text: Self = Self(3);

        pub const ENUM_MIN: i32 = 0;
        pub const ENUM_MAX: i32 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Json, Self::Toml, Self::Csv, Self::Text];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Json => Some("Json"),
                Self::Toml => Some("Toml"),
                Self::Csv => Some("Csv"),
                Self::Text => Some("Text"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TextMessageFormatType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TextMessageFormatType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TextMessageFormatType {
        type Output = TextMessageFormatType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TextMessageFormatType {
        type Scalar = i32;
        #[inline]
        fn to_little_endian(self) -> i32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i32) -> Self {
            let b = i32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TextMessageFormatType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TextMessageFormatType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TEXT_ALIGNMENT: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TEXT_ALIGNMENT: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TEXT_ALIGNMENT: [TextAlignment; 3] = [
        TextAlignment::Left,
        TextAlignment::Center,
        TextAlignment::Right,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TextAlignment(pub u8);
    #[allow(non_upper_case_globals)]
    impl TextAlignment {
        pub const Left: Self = Self(0);
        pub const Center: Self = Self(1);
        pub const Right: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Left, Self::Center, Self::Right];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Left => Some("Left"),
                Self::Center => Some("Center"),
                Self::Right => Some("Right"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TextAlignment {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TextAlignment {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TextAlignment {
        type Output = TextAlignment;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TextAlignment {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TextAlignment {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TextAlignment {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MESSAGE_FORMAT_TYPE: i32 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MESSAGE_FORMAT_TYPE: i32 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MESSAGE_FORMAT_TYPE: [MessageFormatType; 2] =
        [MessageFormatType::Png, MessageFormatType::Jpeg];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MessageFormatType(pub i32);
    #[allow(non_upper_case_globals)]
    impl MessageFormatType {
        pub const Png: Self = Self(0);
        pub const Jpeg: Self = Self(1);

        pub const ENUM_MIN: i32 = 0;
        pub const ENUM_MAX: i32 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Png, Self::Jpeg];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Png => Some("Png"),
                Self::Jpeg => Some("Jpeg"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for MessageFormatType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MessageFormatType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for MessageFormatType {
        type Output = MessageFormatType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for MessageFormatType {
        type Scalar = i32;
        #[inline]
        fn to_little_endian(self) -> i32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i32) -> Self {
            let b = i32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MessageFormatType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MessageFormatType {}
    // struct Color, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Color(pub [u8; 16]);
    impl Default for Color {
        fn default() -> Self {
            Self([0; 16])
        }
    }
    impl core::fmt::Debug for Color {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Color")
                .field("r", &self.r())
                .field("g", &self.g())
                .field("b", &self.b())
                .field("a", &self.a())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Color {}
    impl<'a> flatbuffers::Follow<'a> for Color {
        type Inner = &'a Color;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Color>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Color {
        type Inner = &'a Color;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Color>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Color {
        type Output = Color;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const Color as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for Color {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Color {
        #[allow(clippy::too_many_arguments)]
        pub fn new(r: f32, g: f32, b: f32, a: f32) -> Self {
            let mut s = Self([0; 16]);
            s.set_r(r);
            s.set_g(g);
            s.set_b(b);
            s.set_a(a);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.Color"
        }

        pub fn r(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_r(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn g(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_g(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn b(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_b(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn a(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_a(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> ColorT {
            ColorT {
                r: self.r(),
                g: self.g(),
                b: self.b(),
                a: self.a(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct ColorT {
        pub r: f32,
        pub g: f32,
        pub b: f32,
        pub a: f32,
    }
    impl ColorT {
        pub fn pack(&self) -> Color {
            Color::new(self.r, self.g, self.b, self.a)
        }
    }

    // struct DrawCircle, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct DrawCircle(pub [u8; 40]);
    impl Default for DrawCircle {
        fn default() -> Self {
            Self([0; 40])
        }
    }
    impl core::fmt::Debug for DrawCircle {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("DrawCircle")
                .field("position", &self.position())
                .field("z", &self.z())
                .field("radius", &self.radius())
                .field("subdivisions", &self.subdivisions())
                .field("rotation", &self.rotation())
                .field("color", &self.color())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for DrawCircle {}
    impl<'a> flatbuffers::Follow<'a> for DrawCircle {
        type Inner = &'a DrawCircle;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a DrawCircle>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a DrawCircle {
        type Inner = &'a DrawCircle;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<DrawCircle>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for DrawCircle {
        type Output = DrawCircle;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const DrawCircle as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for DrawCircle {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> DrawCircle {
        #[allow(clippy::too_many_arguments)]
        pub fn new(
            position: &super::Vec2,
            z: f32,
            radius: f32,
            subdivisions: u32,
            rotation: f32,
            color: &Color,
        ) -> Self {
            let mut s = Self([0; 40]);
            s.set_position(position);
            s.set_z(z);
            s.set_radius(radius);
            s.set_subdivisions(subdivisions);
            s.set_rotation(rotation);
            s.set_color(color);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.DrawCircle"
        }

        pub fn position(&self) -> &super::Vec2 {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[0..].as_ptr() as *const super::Vec2) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_position(&mut self, x: &super::Vec2) {
            self.0[0..0 + 8].copy_from_slice(&x.0)
        }

        pub fn z(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_z(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn radius(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[12..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_radius(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[12..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn subdivisions(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[16..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_subdivisions(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[16..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn rotation(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[20..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_rotation(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[20..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn color(&self) -> &Color {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[24..].as_ptr() as *const Color) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_color(&mut self, x: &Color) {
            self.0[24..24 + 16].copy_from_slice(&x.0)
        }

        pub fn unpack(&self) -> DrawCircleT {
            DrawCircleT {
                position: self.position().unpack(),
                z: self.z(),
                radius: self.radius(),
                subdivisions: self.subdivisions(),
                rotation: self.rotation(),
                color: self.color().unpack(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct DrawCircleT {
        pub position: super::Vec2T,
        pub z: f32,
        pub radius: f32,
        pub subdivisions: u32,
        pub rotation: f32,
        pub color: ColorT,
    }
    impl DrawCircleT {
        pub fn pack(&self) -> DrawCircle {
            DrawCircle::new(
                &self.position.pack(),
                self.z,
                self.radius,
                self.subdivisions,
                self.rotation,
                &self.color.pack(),
            )
        }
    }

    // struct DrawLine, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct DrawLine(pub [u8; 40]);
    impl Default for DrawLine {
        fn default() -> Self {
            Self([0; 40])
        }
    }
    impl core::fmt::Debug for DrawLine {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("DrawLine")
                .field("from", &self.from())
                .field("to", &self.to())
                .field("z", &self.z())
                .field("thickness", &self.thickness())
                .field("color", &self.color())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for DrawLine {}
    impl<'a> flatbuffers::Follow<'a> for DrawLine {
        type Inner = &'a DrawLine;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a DrawLine>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a DrawLine {
        type Inner = &'a DrawLine;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<DrawLine>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for DrawLine {
        type Output = DrawLine;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const DrawLine as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for DrawLine {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> DrawLine {
        #[allow(clippy::too_many_arguments)]
        pub fn new(
            from: &super::Vec2,
            to: &super::Vec2,
            z: f32,
            thickness: f32,
            color: &Color,
        ) -> Self {
            let mut s = Self([0; 40]);
            s.set_from(from);
            s.set_to(to);
            s.set_z(z);
            s.set_thickness(thickness);
            s.set_color(color);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.DrawLine"
        }

        pub fn from(&self) -> &super::Vec2 {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[0..].as_ptr() as *const super::Vec2) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_from(&mut self, x: &super::Vec2) {
            self.0[0..0 + 8].copy_from_slice(&x.0)
        }

        pub fn to(&self) -> &super::Vec2 {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[8..].as_ptr() as *const super::Vec2) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_to(&mut self, x: &super::Vec2) {
            self.0[8..8 + 8].copy_from_slice(&x.0)
        }

        pub fn z(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[16..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_z(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[16..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn thickness(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[20..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_thickness(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[20..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn color(&self) -> &Color {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid struct in this slot
            unsafe { &*(self.0[24..].as_ptr() as *const Color) }
        }

        #[allow(clippy::identity_op)]
        pub fn set_color(&mut self, x: &Color) {
            self.0[24..24 + 16].copy_from_slice(&x.0)
        }

        pub fn unpack(&self) -> DrawLineT {
            DrawLineT {
                from: self.from().unpack(),
                to: self.to().unpack(),
                z: self.z(),
                thickness: self.thickness(),
                color: self.color().unpack(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct DrawLineT {
        pub from: super::Vec2T,
        pub to: super::Vec2T,
        pub z: f32,
        pub thickness: f32,
        pub color: ColorT,
    }
    impl DrawLineT {
        pub fn pack(&self) -> DrawLine {
            DrawLine::new(
                &self.from.pack(),
                &self.to.pack(),
                self.z,
                self.thickness,
                &self.color.pack(),
            )
        }
    }

    // struct NewPipeline, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct NewPipeline(pub [u8; 8]);
    impl Default for NewPipeline {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for NewPipeline {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("NewPipeline")
                .field("id", &self.id())
                .field("material_id", &self.material_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for NewPipeline {}
    impl<'a> flatbuffers::Follow<'a> for NewPipeline {
        type Inner = &'a NewPipeline;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a NewPipeline>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a NewPipeline {
        type Inner = &'a NewPipeline;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<NewPipeline>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for NewPipeline {
        type Output = NewPipeline;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const NewPipeline as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for NewPipeline {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> NewPipeline {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: u32, material_id: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_id(id);
            s.set_material_id(material_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.NewPipeline"
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn material_id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_material_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> NewPipelineT {
            NewPipelineT {
                id: self.id(),
                material_id: self.material_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct NewPipelineT {
        pub id: u32,
        pub material_id: u32,
    }
    impl NewPipelineT {
        pub fn pack(&self) -> NewPipeline {
            NewPipeline::new(self.id, self.material_id)
        }
    }

    // struct PipelineLoaded, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct PipelineLoaded(pub [u8; 8]);
    impl Default for PipelineLoaded {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for PipelineLoaded {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("PipelineLoaded")
                .field("id", &self.id())
                .field("material_id", &self.material_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for PipelineLoaded {}
    impl<'a> flatbuffers::Follow<'a> for PipelineLoaded {
        type Inner = &'a PipelineLoaded;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a PipelineLoaded>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a PipelineLoaded {
        type Inner = &'a PipelineLoaded;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<PipelineLoaded>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for PipelineLoaded {
        type Output = PipelineLoaded;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const PipelineLoaded as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for PipelineLoaded {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> PipelineLoaded {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: u32, material_id: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_id(id);
            s.set_material_id(material_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.PipelineLoaded"
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn material_id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_material_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> PipelineLoadedT {
            PipelineLoadedT {
                id: self.id(),
                material_id: self.material_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct PipelineLoadedT {
        pub id: u32,
        pub material_id: u32,
    }
    impl PipelineLoadedT {
        pub fn pack(&self) -> PipelineLoaded {
            PipelineLoaded::new(self.id, self.material_id)
        }
    }

    // struct ReloadPipeline, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct ReloadPipeline(pub [u8; 8]);
    impl Default for ReloadPipeline {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for ReloadPipeline {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("ReloadPipeline")
                .field("id", &self.id())
                .field("material_id", &self.material_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ReloadPipeline {}
    impl<'a> flatbuffers::Follow<'a> for ReloadPipeline {
        type Inner = &'a ReloadPipeline;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a ReloadPipeline>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a ReloadPipeline {
        type Inner = &'a ReloadPipeline;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<ReloadPipeline>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for ReloadPipeline {
        type Output = ReloadPipeline;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const ReloadPipeline as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for ReloadPipeline {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> ReloadPipeline {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: u32, material_id: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_id(id);
            s.set_material_id(material_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.ReloadPipeline"
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn material_id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_material_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> ReloadPipelineT {
            ReloadPipelineT {
                id: self.id(),
                material_id: self.material_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct ReloadPipelineT {
        pub id: u32,
        pub material_id: u32,
    }
    impl ReloadPipelineT {
        pub fn pack(&self) -> ReloadPipeline {
            ReloadPipeline::new(self.id, self.material_id)
        }
    }

    // struct MaterialIdFromTextId, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct MaterialIdFromTextId(pub [u8; 8]);
    impl Default for MaterialIdFromTextId {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for MaterialIdFromTextId {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("MaterialIdFromTextId")
                .field("material_id", &self.material_id())
                .field("text_id", &self.text_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MaterialIdFromTextId {}
    impl<'a> flatbuffers::Follow<'a> for MaterialIdFromTextId {
        type Inner = &'a MaterialIdFromTextId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a MaterialIdFromTextId>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a MaterialIdFromTextId {
        type Inner = &'a MaterialIdFromTextId;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<MaterialIdFromTextId>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for MaterialIdFromTextId {
        type Output = MaterialIdFromTextId;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const MaterialIdFromTextId as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for MaterialIdFromTextId {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> MaterialIdFromTextId {
        #[allow(clippy::too_many_arguments)]
        pub fn new(material_id: u32, text_id: u32) -> Self {
            let mut s = Self([0; 8]);
            s.set_material_id(material_id);
            s.set_text_id(text_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.MaterialIdFromTextId"
        }

        pub fn material_id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_material_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn text_id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_text_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> MaterialIdFromTextIdT {
            MaterialIdFromTextIdT {
                material_id: self.material_id(),
                text_id: self.text_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct MaterialIdFromTextIdT {
        pub material_id: u32,
        pub text_id: u32,
    }
    impl MaterialIdFromTextIdT {
        pub fn pack(&self) -> MaterialIdFromTextId {
            MaterialIdFromTextId::new(self.material_id, self.text_id)
        }
    }

    pub enum DrawRectangleOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DrawRectangle<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DrawRectangle<'a> {
        type Inner = DrawRectangle<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DrawRectangle<'a> {
        pub const VT_TRANSFORM: flatbuffers::VOffsetT = 4;
        pub const VT_COLOR: flatbuffers::VOffsetT = 6;
        pub const VT_ASSET_ID: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.DrawRectangle"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DrawRectangle { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args DrawRectangleArgs<'args>,
        ) -> flatbuffers::WIPOffset<DrawRectangle<'bldr>> {
            let mut builder = DrawRectangleBuilder::new(_fbb);
            if let Some(x) = args.asset_id {
                builder.add_asset_id(x);
            }
            if let Some(x) = args.color {
                builder.add_color(x);
            }
            if let Some(x) = args.transform {
                builder.add_transform(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> DrawRectangleT {
            let transform = self.transform().map(|x| x.unpack());
            let color = self.color().map(|x| x.unpack());
            let asset_id = self.asset_id();
            DrawRectangleT {
                transform,
                color,
                asset_id,
            }
        }

        #[inline]
        pub fn transform(&self) -> Option<&'a super::Transform> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<super::Transform>(DrawRectangle::VT_TRANSFORM, None)
            }
        }
        #[inline]
        pub fn color(&self) -> Option<&'a Color> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Color>(DrawRectangle::VT_COLOR, None) }
        }
        #[inline]
        pub fn asset_id(&self) -> Option<u32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(DrawRectangle::VT_ASSET_ID, None) }
        }
    }

    impl flatbuffers::Verifiable for DrawRectangle<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<super::Transform>("transform", Self::VT_TRANSFORM, false)?
                .visit_field::<Color>("color", Self::VT_COLOR, false)?
                .visit_field::<u32>("asset_id", Self::VT_ASSET_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DrawRectangleArgs<'a> {
        pub transform: Option<&'a super::Transform>,
        pub color: Option<&'a Color>,
        pub asset_id: Option<u32>,
    }
    impl<'a> Default for DrawRectangleArgs<'a> {
        #[inline]
        fn default() -> Self {
            DrawRectangleArgs {
                transform: None,
                color: None,
                asset_id: None,
            }
        }
    }

    pub struct DrawRectangleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DrawRectangleBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transform(&mut self, transform: &super::Transform) {
            self.fbb_
                .push_slot_always::<&super::Transform>(DrawRectangle::VT_TRANSFORM, transform);
        }
        #[inline]
        pub fn add_color(&mut self, color: &Color) {
            self.fbb_
                .push_slot_always::<&Color>(DrawRectangle::VT_COLOR, color);
        }
        #[inline]
        pub fn add_asset_id(&mut self, asset_id: u32) {
            self.fbb_
                .push_slot_always::<u32>(DrawRectangle::VT_ASSET_ID, asset_id);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> DrawRectangleBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            DrawRectangleBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DrawRectangle<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DrawRectangle<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DrawRectangle");
            ds.field("transform", &self.transform());
            ds.field("color", &self.color());
            ds.field("asset_id", &self.asset_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DrawRectangleT {
        pub transform: Option<super::TransformT>,
        pub color: Option<ColorT>,
        pub asset_id: Option<u32>,
    }
    impl Default for DrawRectangleT {
        fn default() -> Self {
            Self {
                transform: None,
                color: None,
                asset_id: None,
            }
        }
    }
    impl DrawRectangleT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<DrawRectangle<'b>> {
            let transform_tmp = self.transform.as_ref().map(|x| x.pack());
            let transform = transform_tmp.as_ref();
            let color_tmp = self.color.as_ref().map(|x| x.pack());
            let color = color_tmp.as_ref();
            let asset_id = self.asset_id;
            DrawRectangle::create(
                _fbb,
                &DrawRectangleArgs {
                    transform,
                    color,
                    asset_id,
                },
            )
        }
    }
    pub enum NewTextOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NewText<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NewText<'a> {
        type Inner = NewText<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NewText<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ASSET_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_SET_UP_WATCHER: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.NewText"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NewText { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NewTextArgs<'args>,
        ) -> flatbuffers::WIPOffset<NewText<'bldr>> {
            let mut builder = NewTextBuilder::new(_fbb);
            if let Some(x) = args.asset_path {
                builder.add_asset_path(x);
            }
            builder.add_id(args.id);
            builder.add_set_up_watcher(args.set_up_watcher);
            builder.finish()
        }

        pub fn unpack(&self) -> NewTextT {
            let id = self.id();
            let asset_path = self.asset_path().map(|x| x.to_string());
            let set_up_watcher = self.set_up_watcher();
            NewTextT {
                id,
                asset_path,
                set_up_watcher,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(NewText::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn asset_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(NewText::VT_ASSET_PATH, None)
            }
        }
        #[inline]
        pub fn set_up_watcher(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(NewText::VT_SET_UP_WATCHER, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for NewText<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "asset_path",
                    Self::VT_ASSET_PATH,
                    false,
                )?
                .visit_field::<bool>("set_up_watcher", Self::VT_SET_UP_WATCHER, false)?
                .finish();
            Ok(())
        }
    }
    pub struct NewTextArgs<'a> {
        pub id: u32,
        pub asset_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub set_up_watcher: bool,
    }
    impl<'a> Default for NewTextArgs<'a> {
        #[inline]
        fn default() -> Self {
            NewTextArgs {
                id: 0,
                asset_path: None,
                set_up_watcher: false,
            }
        }
    }

    pub struct NewTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NewTextBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(NewText::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_asset_path(&mut self, asset_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NewText::VT_ASSET_PATH, asset_path);
        }
        #[inline]
        pub fn add_set_up_watcher(&mut self, set_up_watcher: bool) {
            self.fbb_
                .push_slot::<bool>(NewText::VT_SET_UP_WATCHER, set_up_watcher, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NewTextBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NewTextBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NewText<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NewText<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NewText");
            ds.field("id", &self.id());
            ds.field("asset_path", &self.asset_path());
            ds.field("set_up_watcher", &self.set_up_watcher());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct NewTextT {
        pub id: u32,
        pub asset_path: Option<String>,
        pub set_up_watcher: bool,
    }
    impl Default for NewTextT {
        fn default() -> Self {
            Self {
                id: 0,
                asset_path: None,
                set_up_watcher: false,
            }
        }
    }
    impl NewTextT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<NewText<'b>> {
            let id = self.id;
            let asset_path = self.asset_path.as_ref().map(|x| _fbb.create_string(x));
            let set_up_watcher = self.set_up_watcher;
            NewText::create(
                _fbb,
                &NewTextArgs {
                    id,
                    asset_path,
                    set_up_watcher,
                },
            )
        }
    }
    pub enum TextLoadedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TextLoaded<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TextLoaded<'a> {
        type Inner = TextLoaded<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TextLoaded<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ASSET_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_VERSION: flatbuffers::VOffsetT = 8;
        pub const VT_RAW_TEXT: flatbuffers::VOffsetT = 10;
        pub const VT_FORMAT: flatbuffers::VOffsetT = 12;
        pub const VT_WATCHER_SET_UP: flatbuffers::VOffsetT = 14;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.TextLoaded"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TextLoaded { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TextLoadedArgs<'args>,
        ) -> flatbuffers::WIPOffset<TextLoaded<'bldr>> {
            let mut builder = TextLoadedBuilder::new(_fbb);
            builder.add_format(args.format);
            if let Some(x) = args.raw_text {
                builder.add_raw_text(x);
            }
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            if let Some(x) = args.asset_path {
                builder.add_asset_path(x);
            }
            builder.add_id(args.id);
            builder.add_watcher_set_up(args.watcher_set_up);
            builder.finish()
        }

        pub fn unpack(&self) -> TextLoadedT {
            let id = self.id();
            let asset_path = self.asset_path().map(|x| x.to_string());
            let version = self.version().map(|x| x.into_iter().collect());
            let raw_text = self.raw_text().map(|x| x.to_string());
            let format = self.format();
            let watcher_set_up = self.watcher_set_up();
            TextLoadedT {
                id,
                asset_path,
                version,
                raw_text,
                format,
                watcher_set_up,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TextLoaded::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn asset_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextLoaded::VT_ASSET_PATH, None)
            }
        }
        #[inline]
        pub fn version(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TextLoaded::VT_VERSION,
                        None,
                    )
            }
        }
        #[inline]
        pub fn raw_text(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextLoaded::VT_RAW_TEXT, None)
            }
        }
        #[inline]
        pub fn format(&self) -> TextMessageFormatType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TextMessageFormatType>(
                        TextLoaded::VT_FORMAT,
                        Some(TextMessageFormatType::Json),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn watcher_set_up(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(TextLoaded::VT_WATCHER_SET_UP, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TextLoaded<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "asset_path",
                    Self::VT_ASSET_PATH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "raw_text",
                    Self::VT_RAW_TEXT,
                    false,
                )?
                .visit_field::<TextMessageFormatType>("format", Self::VT_FORMAT, false)?
                .visit_field::<bool>("watcher_set_up", Self::VT_WATCHER_SET_UP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TextLoadedArgs<'a> {
        pub id: u32,
        pub asset_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub version: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub raw_text: Option<flatbuffers::WIPOffset<&'a str>>,
        pub format: TextMessageFormatType,
        pub watcher_set_up: bool,
    }
    impl<'a> Default for TextLoadedArgs<'a> {
        #[inline]
        fn default() -> Self {
            TextLoadedArgs {
                id: 0,
                asset_path: None,
                version: None,
                raw_text: None,
                format: TextMessageFormatType::Json,
                watcher_set_up: false,
            }
        }
    }

    pub struct TextLoadedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextLoadedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TextLoaded::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_asset_path(&mut self, asset_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TextLoaded::VT_ASSET_PATH,
                asset_path,
            );
        }
        #[inline]
        pub fn add_version(
            &mut self,
            version: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TextLoaded::VT_VERSION, version);
        }
        #[inline]
        pub fn add_raw_text(&mut self, raw_text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TextLoaded::VT_RAW_TEXT, raw_text);
        }
        #[inline]
        pub fn add_format(&mut self, format: TextMessageFormatType) {
            self.fbb_.push_slot::<TextMessageFormatType>(
                TextLoaded::VT_FORMAT,
                format,
                TextMessageFormatType::Json,
            );
        }
        #[inline]
        pub fn add_watcher_set_up(&mut self, watcher_set_up: bool) {
            self.fbb_
                .push_slot::<bool>(TextLoaded::VT_WATCHER_SET_UP, watcher_set_up, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TextLoadedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TextLoadedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TextLoaded<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TextLoaded<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TextLoaded");
            ds.field("id", &self.id());
            ds.field("asset_path", &self.asset_path());
            ds.field("version", &self.version());
            ds.field("raw_text", &self.raw_text());
            ds.field("format", &self.format());
            ds.field("watcher_set_up", &self.watcher_set_up());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextLoadedT {
        pub id: u32,
        pub asset_path: Option<String>,
        pub version: Option<Vec<u8>>,
        pub raw_text: Option<String>,
        pub format: TextMessageFormatType,
        pub watcher_set_up: bool,
    }
    impl Default for TextLoadedT {
        fn default() -> Self {
            Self {
                id: 0,
                asset_path: None,
                version: None,
                raw_text: None,
                format: TextMessageFormatType::Json,
                watcher_set_up: false,
            }
        }
    }
    impl TextLoadedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TextLoaded<'b>> {
            let id = self.id;
            let asset_path = self.asset_path.as_ref().map(|x| _fbb.create_string(x));
            let version = self.version.as_ref().map(|x| _fbb.create_vector(x));
            let raw_text = self.raw_text.as_ref().map(|x| _fbb.create_string(x));
            let format = self.format;
            let watcher_set_up = self.watcher_set_up;
            TextLoaded::create(
                _fbb,
                &TextLoadedArgs {
                    id,
                    asset_path,
                    version,
                    raw_text,
                    format,
                    watcher_set_up,
                },
            )
        }
    }
    pub enum TextReloadedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TextReloaded<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TextReloaded<'a> {
        type Inner = TextReloaded<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TextReloaded<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_VERSION: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.TextReloaded"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TextReloaded { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TextReloadedArgs<'args>,
        ) -> flatbuffers::WIPOffset<TextReloaded<'bldr>> {
            let mut builder = TextReloadedBuilder::new(_fbb);
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> TextReloadedT {
            let id = self.id();
            let version = self.version().map(|x| x.into_iter().collect());
            TextReloadedT { id, version }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TextReloaded::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn version(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TextReloaded::VT_VERSION,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for TextReloaded<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TextReloadedArgs<'a> {
        pub id: u32,
        pub version: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for TextReloadedArgs<'a> {
        #[inline]
        fn default() -> Self {
            TextReloadedArgs {
                id: 0,
                version: None,
            }
        }
    }

    pub struct TextReloadedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextReloadedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TextReloaded::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_version(
            &mut self,
            version: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TextReloaded::VT_VERSION, version);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TextReloadedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TextReloadedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TextReloaded<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TextReloaded<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TextReloaded");
            ds.field("id", &self.id());
            ds.field("version", &self.version());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextReloadedT {
        pub id: u32,
        pub version: Option<Vec<u8>>,
    }
    impl Default for TextReloadedT {
        fn default() -> Self {
            Self {
                id: 0,
                version: None,
            }
        }
    }
    impl TextReloadedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TextReloaded<'b>> {
            let id = self.id;
            let version = self.version.as_ref().map(|x| _fbb.create_vector(x));
            TextReloaded::create(_fbb, &TextReloadedArgs { id, version })
        }
    }
    pub enum TextFailedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TextFailed<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TextFailed<'a> {
        type Inner = TextFailed<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TextFailed<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ASSET_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_REASON: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.TextFailed"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TextFailed { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TextFailedArgs<'args>,
        ) -> flatbuffers::WIPOffset<TextFailed<'bldr>> {
            let mut builder = TextFailedBuilder::new(_fbb);
            if let Some(x) = args.reason {
                builder.add_reason(x);
            }
            if let Some(x) = args.asset_path {
                builder.add_asset_path(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> TextFailedT {
            let id = self.id();
            let asset_path = self.asset_path().map(|x| x.to_string());
            let reason = self.reason().map(|x| x.to_string());
            TextFailedT {
                id,
                asset_path,
                reason,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TextFailed::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn asset_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextFailed::VT_ASSET_PATH, None)
            }
        }
        #[inline]
        pub fn reason(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextFailed::VT_REASON, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TextFailed<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "asset_path",
                    Self::VT_ASSET_PATH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "reason",
                    Self::VT_REASON,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TextFailedArgs<'a> {
        pub id: u32,
        pub asset_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TextFailedArgs<'a> {
        #[inline]
        fn default() -> Self {
            TextFailedArgs {
                id: 0,
                asset_path: None,
                reason: None,
            }
        }
    }

    pub struct TextFailedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextFailedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TextFailed::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_asset_path(&mut self, asset_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TextFailed::VT_ASSET_PATH,
                asset_path,
            );
        }
        #[inline]
        pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TextFailed::VT_REASON, reason);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TextFailedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TextFailedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TextFailed<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TextFailed<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TextFailed");
            ds.field("id", &self.id());
            ds.field("asset_path", &self.asset_path());
            ds.field("reason", &self.reason());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextFailedT {
        pub id: u32,
        pub asset_path: Option<String>,
        pub reason: Option<String>,
    }
    impl Default for TextFailedT {
        fn default() -> Self {
            Self {
                id: 0,
                asset_path: None,
                reason: None,
            }
        }
    }
    impl TextFailedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TextFailed<'b>> {
            let id = self.id;
            let asset_path = self.asset_path.as_ref().map(|x| _fbb.create_string(x));
            let reason = self.reason.as_ref().map(|x| _fbb.create_string(x));
            TextFailed::create(
                _fbb,
                &TextFailedArgs {
                    id,
                    asset_path,
                    reason,
                },
            )
        }
    }
    pub enum DrawTextOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DrawText<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DrawText<'a> {
        type Inner = DrawText<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DrawText<'a> {
        pub const VT_TRANSFORM: flatbuffers::VOffsetT = 4;
        pub const VT_Z: flatbuffers::VOffsetT = 6;
        pub const VT_BOUNDS: flatbuffers::VOffsetT = 8;
        pub const VT_TEXT: flatbuffers::VOffsetT = 10;
        pub const VT_COLOR: flatbuffers::VOffsetT = 12;
        pub const VT_FONT_SIZE: flatbuffers::VOffsetT = 14;
        pub const VT_TEXT_ALIGNMENT: flatbuffers::VOffsetT = 16;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.DrawText"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DrawText { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args DrawTextArgs<'args>,
        ) -> flatbuffers::WIPOffset<DrawText<'bldr>> {
            let mut builder = DrawTextBuilder::new(_fbb);
            builder.add_font_size(args.font_size);
            if let Some(x) = args.color {
                builder.add_color(x);
            }
            if let Some(x) = args.text {
                builder.add_text(x);
            }
            if let Some(x) = args.bounds {
                builder.add_bounds(x);
            }
            builder.add_z(args.z);
            if let Some(x) = args.transform {
                builder.add_transform(x);
            }
            builder.add_text_alignment(args.text_alignment);
            builder.finish()
        }

        pub fn unpack(&self) -> DrawTextT {
            let transform = self.transform().map(|x| x.unpack());
            let z = self.z();
            let bounds = self.bounds().map(|x| x.unpack());
            let text = self.text().map(|x| x.to_string());
            let color = self.color().map(|x| x.unpack());
            let font_size = self.font_size();
            let text_alignment = self.text_alignment();
            DrawTextT {
                transform,
                z,
                bounds,
                text,
                color,
                font_size,
                text_alignment,
            }
        }

        #[inline]
        pub fn transform(&self) -> Option<&'a super::Transform> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<super::Transform>(DrawText::VT_TRANSFORM, None)
            }
        }
        #[inline]
        pub fn z(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f32>(DrawText::VT_Z, Some(0.0)).unwrap() }
        }
        #[inline]
        pub fn bounds(&self) -> Option<&'a super::Vec2> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<super::Vec2>(DrawText::VT_BOUNDS, None) }
        }
        #[inline]
        pub fn text(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(DrawText::VT_TEXT, None)
            }
        }
        #[inline]
        pub fn color(&self) -> Option<&'a Color> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Color>(DrawText::VT_COLOR, None) }
        }
        #[inline]
        pub fn font_size(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(DrawText::VT_FONT_SIZE, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn text_alignment(&self) -> TextAlignment {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TextAlignment>(DrawText::VT_TEXT_ALIGNMENT, Some(TextAlignment::Left))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DrawText<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<super::Transform>("transform", Self::VT_TRANSFORM, false)?
                .visit_field::<f32>("z", Self::VT_Z, false)?
                .visit_field::<super::Vec2>("bounds", Self::VT_BOUNDS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
                .visit_field::<Color>("color", Self::VT_COLOR, false)?
                .visit_field::<f32>("font_size", Self::VT_FONT_SIZE, false)?
                .visit_field::<TextAlignment>("text_alignment", Self::VT_TEXT_ALIGNMENT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DrawTextArgs<'a> {
        pub transform: Option<&'a super::Transform>,
        pub z: f32,
        pub bounds: Option<&'a super::Vec2>,
        pub text: Option<flatbuffers::WIPOffset<&'a str>>,
        pub color: Option<&'a Color>,
        pub font_size: f32,
        pub text_alignment: TextAlignment,
    }
    impl<'a> Default for DrawTextArgs<'a> {
        #[inline]
        fn default() -> Self {
            DrawTextArgs {
                transform: None,
                z: 0.0,
                bounds: None,
                text: None,
                color: None,
                font_size: 0.0,
                text_alignment: TextAlignment::Left,
            }
        }
    }

    pub struct DrawTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DrawTextBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_transform(&mut self, transform: &super::Transform) {
            self.fbb_
                .push_slot_always::<&super::Transform>(DrawText::VT_TRANSFORM, transform);
        }
        #[inline]
        pub fn add_z(&mut self, z: f32) {
            self.fbb_.push_slot::<f32>(DrawText::VT_Z, z, 0.0);
        }
        #[inline]
        pub fn add_bounds(&mut self, bounds: &super::Vec2) {
            self.fbb_
                .push_slot_always::<&super::Vec2>(DrawText::VT_BOUNDS, bounds);
        }
        #[inline]
        pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DrawText::VT_TEXT, text);
        }
        #[inline]
        pub fn add_color(&mut self, color: &Color) {
            self.fbb_
                .push_slot_always::<&Color>(DrawText::VT_COLOR, color);
        }
        #[inline]
        pub fn add_font_size(&mut self, font_size: f32) {
            self.fbb_
                .push_slot::<f32>(DrawText::VT_FONT_SIZE, font_size, 0.0);
        }
        #[inline]
        pub fn add_text_alignment(&mut self, text_alignment: TextAlignment) {
            self.fbb_.push_slot::<TextAlignment>(
                DrawText::VT_TEXT_ALIGNMENT,
                text_alignment,
                TextAlignment::Left,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> DrawTextBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            DrawTextBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DrawText<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DrawText<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DrawText");
            ds.field("transform", &self.transform());
            ds.field("z", &self.z());
            ds.field("bounds", &self.bounds());
            ds.field("text", &self.text());
            ds.field("color", &self.color());
            ds.field("font_size", &self.font_size());
            ds.field("text_alignment", &self.text_alignment());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DrawTextT {
        pub transform: Option<super::TransformT>,
        pub z: f32,
        pub bounds: Option<super::Vec2T>,
        pub text: Option<String>,
        pub color: Option<ColorT>,
        pub font_size: f32,
        pub text_alignment: TextAlignment,
    }
    impl Default for DrawTextT {
        fn default() -> Self {
            Self {
                transform: None,
                z: 0.0,
                bounds: None,
                text: None,
                color: None,
                font_size: 0.0,
                text_alignment: TextAlignment::Left,
            }
        }
    }
    impl DrawTextT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<DrawText<'b>> {
            let transform_tmp = self.transform.as_ref().map(|x| x.pack());
            let transform = transform_tmp.as_ref();
            let z = self.z;
            let bounds_tmp = self.bounds.as_ref().map(|x| x.pack());
            let bounds = bounds_tmp.as_ref();
            let text = self.text.as_ref().map(|x| _fbb.create_string(x));
            let color_tmp = self.color.as_ref().map(|x| x.pack());
            let color = color_tmp.as_ref();
            let font_size = self.font_size;
            let text_alignment = self.text_alignment;
            DrawText::create(
                _fbb,
                &DrawTextArgs {
                    transform,
                    z,
                    bounds,
                    text,
                    color,
                    font_size,
                    text_alignment,
                },
            )
        }
    }
    pub enum NewTextureOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NewTexture<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NewTexture<'a> {
        type Inner = NewTexture<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NewTexture<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ASSET_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_INSERT_IN_ATLAS: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.NewTexture"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NewTexture { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args NewTextureArgs<'args>,
        ) -> flatbuffers::WIPOffset<NewTexture<'bldr>> {
            let mut builder = NewTextureBuilder::new(_fbb);
            if let Some(x) = args.asset_path {
                builder.add_asset_path(x);
            }
            builder.add_id(args.id);
            builder.add_insert_in_atlas(args.insert_in_atlas);
            builder.finish()
        }

        pub fn unpack(&self) -> NewTextureT {
            let id = self.id();
            let asset_path = self.asset_path().map(|x| x.to_string());
            let insert_in_atlas = self.insert_in_atlas();
            NewTextureT {
                id,
                asset_path,
                insert_in_atlas,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(NewTexture::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn asset_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(NewTexture::VT_ASSET_PATH, None)
            }
        }
        #[inline]
        pub fn insert_in_atlas(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(NewTexture::VT_INSERT_IN_ATLAS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for NewTexture<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "asset_path",
                    Self::VT_ASSET_PATH,
                    false,
                )?
                .visit_field::<bool>("insert_in_atlas", Self::VT_INSERT_IN_ATLAS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct NewTextureArgs<'a> {
        pub id: u32,
        pub asset_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub insert_in_atlas: bool,
    }
    impl<'a> Default for NewTextureArgs<'a> {
        #[inline]
        fn default() -> Self {
            NewTextureArgs {
                id: 0,
                asset_path: None,
                insert_in_atlas: false,
            }
        }
    }

    pub struct NewTextureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NewTextureBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(NewTexture::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_asset_path(&mut self, asset_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                NewTexture::VT_ASSET_PATH,
                asset_path,
            );
        }
        #[inline]
        pub fn add_insert_in_atlas(&mut self, insert_in_atlas: bool) {
            self.fbb_
                .push_slot::<bool>(NewTexture::VT_INSERT_IN_ATLAS, insert_in_atlas, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> NewTextureBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            NewTextureBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NewTexture<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NewTexture<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NewTexture");
            ds.field("id", &self.id());
            ds.field("asset_path", &self.asset_path());
            ds.field("insert_in_atlas", &self.insert_in_atlas());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct NewTextureT {
        pub id: u32,
        pub asset_path: Option<String>,
        pub insert_in_atlas: bool,
    }
    impl Default for NewTextureT {
        fn default() -> Self {
            Self {
                id: 0,
                asset_path: None,
                insert_in_atlas: false,
            }
        }
    }
    impl NewTextureT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<NewTexture<'b>> {
            let id = self.id;
            let asset_path = self.asset_path.as_ref().map(|x| _fbb.create_string(x));
            let insert_in_atlas = self.insert_in_atlas;
            NewTexture::create(
                _fbb,
                &NewTextureArgs {
                    id,
                    asset_path,
                    insert_in_atlas,
                },
            )
        }
    }
    pub enum TextureLoadedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TextureLoaded<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TextureLoaded<'a> {
        type Inner = TextureLoaded<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TextureLoaded<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ASSET_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_VERSION: flatbuffers::VOffsetT = 8;
        pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;
        pub const VT_FORMAT: flatbuffers::VOffsetT = 14;
        pub const VT_IN_ATLAS: flatbuffers::VOffsetT = 16;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.TextureLoaded"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TextureLoaded { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TextureLoadedArgs<'args>,
        ) -> flatbuffers::WIPOffset<TextureLoaded<'bldr>> {
            let mut builder = TextureLoadedBuilder::new(_fbb);
            builder.add_format(args.format);
            builder.add_height(args.height);
            builder.add_width(args.width);
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            if let Some(x) = args.asset_path {
                builder.add_asset_path(x);
            }
            builder.add_id(args.id);
            builder.add_in_atlas(args.in_atlas);
            builder.finish()
        }

        pub fn unpack(&self) -> TextureLoadedT {
            let id = self.id();
            let asset_path = self.asset_path().map(|x| x.to_string());
            let version = self.version().map(|x| x.into_iter().collect());
            let width = self.width();
            let height = self.height();
            let format = self.format();
            let in_atlas = self.in_atlas();
            TextureLoadedT {
                id,
                asset_path,
                version,
                width,
                height,
                format,
                in_atlas,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TextureLoaded::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn asset_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextureLoaded::VT_ASSET_PATH, None)
            }
        }
        #[inline]
        pub fn version(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        TextureLoaded::VT_VERSION,
                        None,
                    )
            }
        }
        #[inline]
        pub fn width(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TextureLoaded::VT_WIDTH, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TextureLoaded::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn format(&self) -> MessageFormatType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<MessageFormatType>(
                        TextureLoaded::VT_FORMAT,
                        Some(MessageFormatType::Png),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn in_atlas(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(TextureLoaded::VT_IN_ATLAS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TextureLoaded<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "asset_path",
                    Self::VT_ASSET_PATH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .visit_field::<u32>("width", Self::VT_WIDTH, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<MessageFormatType>("format", Self::VT_FORMAT, false)?
                .visit_field::<bool>("in_atlas", Self::VT_IN_ATLAS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TextureLoadedArgs<'a> {
        pub id: u32,
        pub asset_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub version: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub width: u32,
        pub height: u32,
        pub format: MessageFormatType,
        pub in_atlas: bool,
    }
    impl<'a> Default for TextureLoadedArgs<'a> {
        #[inline]
        fn default() -> Self {
            TextureLoadedArgs {
                id: 0,
                asset_path: None,
                version: None,
                width: 0,
                height: 0,
                format: MessageFormatType::Png,
                in_atlas: false,
            }
        }
    }

    pub struct TextureLoadedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextureLoadedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TextureLoaded::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_asset_path(&mut self, asset_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TextureLoaded::VT_ASSET_PATH,
                asset_path,
            );
        }
        #[inline]
        pub fn add_version(
            &mut self,
            version: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureLoaded::VT_VERSION, version);
        }
        #[inline]
        pub fn add_width(&mut self, width: u32) {
            self.fbb_
                .push_slot::<u32>(TextureLoaded::VT_WIDTH, width, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(TextureLoaded::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_format(&mut self, format: MessageFormatType) {
            self.fbb_.push_slot::<MessageFormatType>(
                TextureLoaded::VT_FORMAT,
                format,
                MessageFormatType::Png,
            );
        }
        #[inline]
        pub fn add_in_atlas(&mut self, in_atlas: bool) {
            self.fbb_
                .push_slot::<bool>(TextureLoaded::VT_IN_ATLAS, in_atlas, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TextureLoadedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TextureLoadedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TextureLoaded<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TextureLoaded<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TextureLoaded");
            ds.field("id", &self.id());
            ds.field("asset_path", &self.asset_path());
            ds.field("version", &self.version());
            ds.field("width", &self.width());
            ds.field("height", &self.height());
            ds.field("format", &self.format());
            ds.field("in_atlas", &self.in_atlas());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextureLoadedT {
        pub id: u32,
        pub asset_path: Option<String>,
        pub version: Option<Vec<u8>>,
        pub width: u32,
        pub height: u32,
        pub format: MessageFormatType,
        pub in_atlas: bool,
    }
    impl Default for TextureLoadedT {
        fn default() -> Self {
            Self {
                id: 0,
                asset_path: None,
                version: None,
                width: 0,
                height: 0,
                format: MessageFormatType::Png,
                in_atlas: false,
            }
        }
    }
    impl TextureLoadedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TextureLoaded<'b>> {
            let id = self.id;
            let asset_path = self.asset_path.as_ref().map(|x| _fbb.create_string(x));
            let version = self.version.as_ref().map(|x| _fbb.create_vector(x));
            let width = self.width;
            let height = self.height;
            let format = self.format;
            let in_atlas = self.in_atlas;
            TextureLoaded::create(
                _fbb,
                &TextureLoadedArgs {
                    id,
                    asset_path,
                    version,
                    width,
                    height,
                    format,
                    in_atlas,
                },
            )
        }
    }
    pub enum TextureFailedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TextureFailed<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TextureFailed<'a> {
        type Inner = TextureFailed<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TextureFailed<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ASSET_PATH: flatbuffers::VOffsetT = 6;
        pub const VT_REASON: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.TextureFailed"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TextureFailed { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TextureFailedArgs<'args>,
        ) -> flatbuffers::WIPOffset<TextureFailed<'bldr>> {
            let mut builder = TextureFailedBuilder::new(_fbb);
            if let Some(x) = args.reason {
                builder.add_reason(x);
            }
            if let Some(x) = args.asset_path {
                builder.add_asset_path(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> TextureFailedT {
            let id = self.id();
            let asset_path = self.asset_path().map(|x| x.to_string());
            let reason = self.reason().map(|x| x.to_string());
            TextureFailedT {
                id,
                asset_path,
                reason,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TextureFailed::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn asset_path(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextureFailed::VT_ASSET_PATH, None)
            }
        }
        #[inline]
        pub fn reason(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TextureFailed::VT_REASON, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TextureFailed<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "asset_path",
                    Self::VT_ASSET_PATH,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "reason",
                    Self::VT_REASON,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TextureFailedArgs<'a> {
        pub id: u32,
        pub asset_path: Option<flatbuffers::WIPOffset<&'a str>>,
        pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for TextureFailedArgs<'a> {
        #[inline]
        fn default() -> Self {
            TextureFailedArgs {
                id: 0,
                asset_path: None,
                reason: None,
            }
        }
    }

    pub struct TextureFailedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextureFailedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TextureFailed::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_asset_path(&mut self, asset_path: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TextureFailed::VT_ASSET_PATH,
                asset_path,
            );
        }
        #[inline]
        pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TextureFailed::VT_REASON, reason);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TextureFailedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TextureFailedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TextureFailed<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TextureFailed<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TextureFailed");
            ds.field("id", &self.id());
            ds.field("asset_path", &self.asset_path());
            ds.field("reason", &self.reason());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TextureFailedT {
        pub id: u32,
        pub asset_path: Option<String>,
        pub reason: Option<String>,
    }
    impl Default for TextureFailedT {
        fn default() -> Self {
            Self {
                id: 0,
                asset_path: None,
                reason: None,
            }
        }
    }
    impl TextureFailedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<TextureFailed<'b>> {
            let id = self.id;
            let asset_path = self.asset_path.as_ref().map(|x| _fbb.create_string(x));
            let reason = self.reason.as_ref().map(|x| _fbb.create_string(x));
            TextureFailed::create(
                _fbb,
                &TextureFailedArgs {
                    id,
                    asset_path,
                    reason,
                },
            )
        }
    }
    pub enum PipelineFailedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PipelineFailed<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PipelineFailed<'a> {
        type Inner = PipelineFailed<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PipelineFailed<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_MATERIAL_ID: flatbuffers::VOffsetT = 6;
        pub const VT_REASON: flatbuffers::VOffsetT = 8;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Graphics.PipelineFailed"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PipelineFailed { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args PipelineFailedArgs<'args>,
        ) -> flatbuffers::WIPOffset<PipelineFailed<'bldr>> {
            let mut builder = PipelineFailedBuilder::new(_fbb);
            if let Some(x) = args.reason {
                builder.add_reason(x);
            }
            builder.add_material_id(args.material_id);
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> PipelineFailedT {
            let id = self.id();
            let material_id = self.material_id();
            let reason = self.reason().map(|x| x.to_string());
            PipelineFailedT {
                id,
                material_id,
                reason,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(PipelineFailed::VT_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn material_id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(PipelineFailed::VT_MATERIAL_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn reason(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PipelineFailed::VT_REASON, None)
            }
        }
    }

    impl flatbuffers::Verifiable for PipelineFailed<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u32>("material_id", Self::VT_MATERIAL_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "reason",
                    Self::VT_REASON,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PipelineFailedArgs<'a> {
        pub id: u32,
        pub material_id: u32,
        pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for PipelineFailedArgs<'a> {
        #[inline]
        fn default() -> Self {
            PipelineFailedArgs {
                id: 0,
                material_id: 0,
                reason: None,
            }
        }
    }

    pub struct PipelineFailedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PipelineFailedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(PipelineFailed::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_material_id(&mut self, material_id: u32) {
            self.fbb_
                .push_slot::<u32>(PipelineFailed::VT_MATERIAL_ID, material_id, 0);
        }
        #[inline]
        pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PipelineFailed::VT_REASON, reason);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> PipelineFailedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            PipelineFailedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PipelineFailed<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PipelineFailed<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PipelineFailed");
            ds.field("id", &self.id());
            ds.field("material_id", &self.material_id());
            ds.field("reason", &self.reason());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PipelineFailedT {
        pub id: u32,
        pub material_id: u32,
        pub reason: Option<String>,
    }
    impl Default for PipelineFailedT {
        fn default() -> Self {
            Self {
                id: 0,
                material_id: 0,
                reason: None,
            }
        }
    }
    impl PipelineFailedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<PipelineFailed<'b>> {
            let id = self.id;
            let material_id = self.material_id;
            let reason = self.reason.as_ref().map(|x| _fbb.create_string(x));
            PipelineFailed::create(
                _fbb,
                &PipelineFailedArgs {
                    id,
                    material_id,
                    reason,
                },
            )
        }
    }
} // pub mod Graphics

#[allow(unused_imports, dead_code)]
pub mod input {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_KEY_CODE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_KEY_CODE: u8 = 193;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_KEY_CODE: [KeyCode; 194] = [
        KeyCode::Backquote,
        KeyCode::Backslash,
        KeyCode::BracketLeft,
        KeyCode::BracketRight,
        KeyCode::Comma,
        KeyCode::Digit0,
        KeyCode::Digit1,
        KeyCode::Digit2,
        KeyCode::Digit3,
        KeyCode::Digit4,
        KeyCode::Digit5,
        KeyCode::Digit6,
        KeyCode::Digit7,
        KeyCode::Digit8,
        KeyCode::Digit9,
        KeyCode::Equal,
        KeyCode::IntlBackslash,
        KeyCode::IntlRo,
        KeyCode::IntlYen,
        KeyCode::KeyA,
        KeyCode::KeyB,
        KeyCode::KeyC,
        KeyCode::KeyD,
        KeyCode::KeyE,
        KeyCode::KeyF,
        KeyCode::KeyG,
        KeyCode::KeyH,
        KeyCode::KeyI,
        KeyCode::KeyJ,
        KeyCode::KeyK,
        KeyCode::KeyL,
        KeyCode::KeyM,
        KeyCode::KeyN,
        KeyCode::KeyO,
        KeyCode::KeyP,
        KeyCode::KeyQ,
        KeyCode::KeyR,
        KeyCode::KeyS,
        KeyCode::KeyT,
        KeyCode::KeyU,
        KeyCode::KeyV,
        KeyCode::KeyW,
        KeyCode::KeyX,
        KeyCode::KeyY,
        KeyCode::KeyZ,
        KeyCode::Minus,
        KeyCode::Period,
        KeyCode::Quote,
        KeyCode::Semicolon,
        KeyCode::Slash,
        KeyCode::AltLeft,
        KeyCode::AltRight,
        KeyCode::Backspace,
        KeyCode::CapsLock,
        KeyCode::ContextMenu,
        KeyCode::ControlLeft,
        KeyCode::ControlRight,
        KeyCode::Enter,
        KeyCode::MetaLeft,
        KeyCode::MetaRight,
        KeyCode::ShiftLeft,
        KeyCode::ShiftRight,
        KeyCode::Space,
        KeyCode::Tab,
        KeyCode::Convert,
        KeyCode::KanaMode,
        KeyCode::Lang1,
        KeyCode::Lang2,
        KeyCode::Lang3,
        KeyCode::Lang4,
        KeyCode::Lang5,
        KeyCode::NonConvert,
        KeyCode::Delete,
        KeyCode::End,
        KeyCode::Help,
        KeyCode::Home,
        KeyCode::Insert,
        KeyCode::PageDown,
        KeyCode::PageUp,
        KeyCode::ArrowDown,
        KeyCode::ArrowLeft,
        KeyCode::ArrowRight,
        KeyCode::ArrowUp,
        KeyCode::NumLock,
        KeyCode::Numpad0,
        KeyCode::Numpad1,
        KeyCode::Numpad2,
        KeyCode::Numpad3,
        KeyCode::Numpad4,
        KeyCode::Numpad5,
        KeyCode::Numpad6,
        KeyCode::Numpad7,
        KeyCode::Numpad8,
        KeyCode::Numpad9,
        KeyCode::NumpadAdd,
        KeyCode::NumpadBackspace,
        KeyCode::NumpadClear,
        KeyCode::NumpadClearEntry,
        KeyCode::NumpadComma,
        KeyCode::NumpadDecimal,
        KeyCode::NumpadDivide,
        KeyCode::NumpadEnter,
        KeyCode::NumpadEqual,
        KeyCode::NumpadHash,
        KeyCode::NumpadMemoryAdd,
        KeyCode::NumpadMemoryClear,
        KeyCode::NumpadMemoryRecall,
        KeyCode::NumpadMemoryStore,
        KeyCode::NumpadMemorySubtract,
        KeyCode::NumpadMultiply,
        KeyCode::NumpadParenLeft,
        KeyCode::NumpadParenRight,
        KeyCode::NumpadStar,
        KeyCode::NumpadSubtract,
        KeyCode::Escape,
        KeyCode::Fn,
        KeyCode::FnLock,
        KeyCode::PrintScreen,
        KeyCode::ScrollLock,
        KeyCode::Pause,
        KeyCode::BrowserBack,
        KeyCode::BrowserFavorites,
        KeyCode::BrowserForward,
        KeyCode::BrowserHome,
        KeyCode::BrowserRefresh,
        KeyCode::BrowserSearch,
        KeyCode::BrowserStop,
        KeyCode::Eject,
        KeyCode::LaunchApp1,
        KeyCode::LaunchApp2,
        KeyCode::LaunchMail,
        KeyCode::MediaPlayPause,
        KeyCode::MediaSelect,
        KeyCode::MediaStop,
        KeyCode::MediaTrackNext,
        KeyCode::MediaTrackPrevious,
        KeyCode::Power,
        KeyCode::Sleep,
        KeyCode::AudioVolumeDown,
        KeyCode::AudioVolumeMute,
        KeyCode::AudioVolumeUp,
        KeyCode::WakeUp,
        KeyCode::Hyper,
        KeyCode::Super,
        KeyCode::Turbo,
        KeyCode::Abort,
        KeyCode::Resume,
        KeyCode::Suspend,
        KeyCode::Again,
        KeyCode::Copy,
        KeyCode::Cut,
        KeyCode::Find,
        KeyCode::Open,
        KeyCode::Paste,
        KeyCode::Props,
        KeyCode::Select,
        KeyCode::Undo,
        KeyCode::Hiragana,
        KeyCode::Katakana,
        KeyCode::F1,
        KeyCode::F2,
        KeyCode::F3,
        KeyCode::F4,
        KeyCode::F5,
        KeyCode::F6,
        KeyCode::F7,
        KeyCode::F8,
        KeyCode::F9,
        KeyCode::F10,
        KeyCode::F11,
        KeyCode::F12,
        KeyCode::F13,
        KeyCode::F14,
        KeyCode::F15,
        KeyCode::F16,
        KeyCode::F17,
        KeyCode::F18,
        KeyCode::F19,
        KeyCode::F20,
        KeyCode::F21,
        KeyCode::F22,
        KeyCode::F23,
        KeyCode::F24,
        KeyCode::F25,
        KeyCode::F26,
        KeyCode::F27,
        KeyCode::F28,
        KeyCode::F29,
        KeyCode::F30,
        KeyCode::F31,
        KeyCode::F32,
        KeyCode::F33,
        KeyCode::F34,
        KeyCode::F35,
    ];

    /// Conforms to the W3 UI Events spec
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct KeyCode(pub u8);
    #[allow(non_upper_case_globals)]
    impl KeyCode {
        pub const Backquote: Self = Self(0);
        pub const Backslash: Self = Self(1);
        pub const BracketLeft: Self = Self(2);
        pub const BracketRight: Self = Self(3);
        pub const Comma: Self = Self(4);
        pub const Digit0: Self = Self(5);
        pub const Digit1: Self = Self(6);
        pub const Digit2: Self = Self(7);
        pub const Digit3: Self = Self(8);
        pub const Digit4: Self = Self(9);
        pub const Digit5: Self = Self(10);
        pub const Digit6: Self = Self(11);
        pub const Digit7: Self = Self(12);
        pub const Digit8: Self = Self(13);
        pub const Digit9: Self = Self(14);
        pub const Equal: Self = Self(15);
        pub const IntlBackslash: Self = Self(16);
        pub const IntlRo: Self = Self(17);
        pub const IntlYen: Self = Self(18);
        pub const KeyA: Self = Self(19);
        pub const KeyB: Self = Self(20);
        pub const KeyC: Self = Self(21);
        pub const KeyD: Self = Self(22);
        pub const KeyE: Self = Self(23);
        pub const KeyF: Self = Self(24);
        pub const KeyG: Self = Self(25);
        pub const KeyH: Self = Self(26);
        pub const KeyI: Self = Self(27);
        pub const KeyJ: Self = Self(28);
        pub const KeyK: Self = Self(29);
        pub const KeyL: Self = Self(30);
        pub const KeyM: Self = Self(31);
        pub const KeyN: Self = Self(32);
        pub const KeyO: Self = Self(33);
        pub const KeyP: Self = Self(34);
        pub const KeyQ: Self = Self(35);
        pub const KeyR: Self = Self(36);
        pub const KeyS: Self = Self(37);
        pub const KeyT: Self = Self(38);
        pub const KeyU: Self = Self(39);
        pub const KeyV: Self = Self(40);
        pub const KeyW: Self = Self(41);
        pub const KeyX: Self = Self(42);
        pub const KeyY: Self = Self(43);
        pub const KeyZ: Self = Self(44);
        pub const Minus: Self = Self(45);
        pub const Period: Self = Self(46);
        pub const Quote: Self = Self(47);
        pub const Semicolon: Self = Self(48);
        pub const Slash: Self = Self(49);
        pub const AltLeft: Self = Self(50);
        pub const AltRight: Self = Self(51);
        pub const Backspace: Self = Self(52);
        pub const CapsLock: Self = Self(53);
        pub const ContextMenu: Self = Self(54);
        pub const ControlLeft: Self = Self(55);
        pub const ControlRight: Self = Self(56);
        pub const Enter: Self = Self(57);
        pub const MetaLeft: Self = Self(58);
        pub const MetaRight: Self = Self(59);
        pub const ShiftLeft: Self = Self(60);
        pub const ShiftRight: Self = Self(61);
        pub const Space: Self = Self(62);
        pub const Tab: Self = Self(63);
        pub const Convert: Self = Self(64);
        pub const KanaMode: Self = Self(65);
        pub const Lang1: Self = Self(66);
        pub const Lang2: Self = Self(67);
        pub const Lang3: Self = Self(68);
        pub const Lang4: Self = Self(69);
        pub const Lang5: Self = Self(70);
        pub const NonConvert: Self = Self(71);
        pub const Delete: Self = Self(72);
        pub const End: Self = Self(73);
        pub const Help: Self = Self(74);
        pub const Home: Self = Self(75);
        pub const Insert: Self = Self(76);
        pub const PageDown: Self = Self(77);
        pub const PageUp: Self = Self(78);
        pub const ArrowDown: Self = Self(79);
        pub const ArrowLeft: Self = Self(80);
        pub const ArrowRight: Self = Self(81);
        pub const ArrowUp: Self = Self(82);
        pub const NumLock: Self = Self(83);
        pub const Numpad0: Self = Self(84);
        pub const Numpad1: Self = Self(85);
        pub const Numpad2: Self = Self(86);
        pub const Numpad3: Self = Self(87);
        pub const Numpad4: Self = Self(88);
        pub const Numpad5: Self = Self(89);
        pub const Numpad6: Self = Self(90);
        pub const Numpad7: Self = Self(91);
        pub const Numpad8: Self = Self(92);
        pub const Numpad9: Self = Self(93);
        pub const NumpadAdd: Self = Self(94);
        pub const NumpadBackspace: Self = Self(95);
        pub const NumpadClear: Self = Self(96);
        pub const NumpadClearEntry: Self = Self(97);
        pub const NumpadComma: Self = Self(98);
        pub const NumpadDecimal: Self = Self(99);
        pub const NumpadDivide: Self = Self(100);
        pub const NumpadEnter: Self = Self(101);
        pub const NumpadEqual: Self = Self(102);
        pub const NumpadHash: Self = Self(103);
        pub const NumpadMemoryAdd: Self = Self(104);
        pub const NumpadMemoryClear: Self = Self(105);
        pub const NumpadMemoryRecall: Self = Self(106);
        pub const NumpadMemoryStore: Self = Self(107);
        pub const NumpadMemorySubtract: Self = Self(108);
        pub const NumpadMultiply: Self = Self(109);
        pub const NumpadParenLeft: Self = Self(110);
        pub const NumpadParenRight: Self = Self(111);
        pub const NumpadStar: Self = Self(112);
        pub const NumpadSubtract: Self = Self(113);
        pub const Escape: Self = Self(114);
        pub const Fn: Self = Self(115);
        pub const FnLock: Self = Self(116);
        pub const PrintScreen: Self = Self(117);
        pub const ScrollLock: Self = Self(118);
        pub const Pause: Self = Self(119);
        pub const BrowserBack: Self = Self(120);
        pub const BrowserFavorites: Self = Self(121);
        pub const BrowserForward: Self = Self(122);
        pub const BrowserHome: Self = Self(123);
        pub const BrowserRefresh: Self = Self(124);
        pub const BrowserSearch: Self = Self(125);
        pub const BrowserStop: Self = Self(126);
        pub const Eject: Self = Self(127);
        pub const LaunchApp1: Self = Self(128);
        pub const LaunchApp2: Self = Self(129);
        pub const LaunchMail: Self = Self(130);
        pub const MediaPlayPause: Self = Self(131);
        pub const MediaSelect: Self = Self(132);
        pub const MediaStop: Self = Self(133);
        pub const MediaTrackNext: Self = Self(134);
        pub const MediaTrackPrevious: Self = Self(135);
        pub const Power: Self = Self(136);
        pub const Sleep: Self = Self(137);
        pub const AudioVolumeDown: Self = Self(138);
        pub const AudioVolumeMute: Self = Self(139);
        pub const AudioVolumeUp: Self = Self(140);
        pub const WakeUp: Self = Self(141);
        pub const Hyper: Self = Self(142);
        pub const Super: Self = Self(143);
        pub const Turbo: Self = Self(144);
        pub const Abort: Self = Self(145);
        pub const Resume: Self = Self(146);
        pub const Suspend: Self = Self(147);
        pub const Again: Self = Self(148);
        pub const Copy: Self = Self(149);
        pub const Cut: Self = Self(150);
        pub const Find: Self = Self(151);
        pub const Open: Self = Self(152);
        pub const Paste: Self = Self(153);
        pub const Props: Self = Self(154);
        pub const Select: Self = Self(155);
        pub const Undo: Self = Self(156);
        pub const Hiragana: Self = Self(157);
        pub const Katakana: Self = Self(158);
        pub const F1: Self = Self(159);
        pub const F2: Self = Self(160);
        pub const F3: Self = Self(161);
        pub const F4: Self = Self(162);
        pub const F5: Self = Self(163);
        pub const F6: Self = Self(164);
        pub const F7: Self = Self(165);
        pub const F8: Self = Self(166);
        pub const F9: Self = Self(167);
        pub const F10: Self = Self(168);
        pub const F11: Self = Self(169);
        pub const F12: Self = Self(170);
        pub const F13: Self = Self(171);
        pub const F14: Self = Self(172);
        pub const F15: Self = Self(173);
        pub const F16: Self = Self(174);
        pub const F17: Self = Self(175);
        pub const F18: Self = Self(176);
        pub const F19: Self = Self(177);
        pub const F20: Self = Self(178);
        pub const F21: Self = Self(179);
        pub const F22: Self = Self(180);
        pub const F23: Self = Self(181);
        pub const F24: Self = Self(182);
        pub const F25: Self = Self(183);
        pub const F26: Self = Self(184);
        pub const F27: Self = Self(185);
        pub const F28: Self = Self(186);
        pub const F29: Self = Self(187);
        pub const F30: Self = Self(188);
        pub const F31: Self = Self(189);
        pub const F32: Self = Self(190);
        pub const F33: Self = Self(191);
        pub const F34: Self = Self(192);
        pub const F35: Self = Self(193);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 193;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::Backquote,
            Self::Backslash,
            Self::BracketLeft,
            Self::BracketRight,
            Self::Comma,
            Self::Digit0,
            Self::Digit1,
            Self::Digit2,
            Self::Digit3,
            Self::Digit4,
            Self::Digit5,
            Self::Digit6,
            Self::Digit7,
            Self::Digit8,
            Self::Digit9,
            Self::Equal,
            Self::IntlBackslash,
            Self::IntlRo,
            Self::IntlYen,
            Self::KeyA,
            Self::KeyB,
            Self::KeyC,
            Self::KeyD,
            Self::KeyE,
            Self::KeyF,
            Self::KeyG,
            Self::KeyH,
            Self::KeyI,
            Self::KeyJ,
            Self::KeyK,
            Self::KeyL,
            Self::KeyM,
            Self::KeyN,
            Self::KeyO,
            Self::KeyP,
            Self::KeyQ,
            Self::KeyR,
            Self::KeyS,
            Self::KeyT,
            Self::KeyU,
            Self::KeyV,
            Self::KeyW,
            Self::KeyX,
            Self::KeyY,
            Self::KeyZ,
            Self::Minus,
            Self::Period,
            Self::Quote,
            Self::Semicolon,
            Self::Slash,
            Self::AltLeft,
            Self::AltRight,
            Self::Backspace,
            Self::CapsLock,
            Self::ContextMenu,
            Self::ControlLeft,
            Self::ControlRight,
            Self::Enter,
            Self::MetaLeft,
            Self::MetaRight,
            Self::ShiftLeft,
            Self::ShiftRight,
            Self::Space,
            Self::Tab,
            Self::Convert,
            Self::KanaMode,
            Self::Lang1,
            Self::Lang2,
            Self::Lang3,
            Self::Lang4,
            Self::Lang5,
            Self::NonConvert,
            Self::Delete,
            Self::End,
            Self::Help,
            Self::Home,
            Self::Insert,
            Self::PageDown,
            Self::PageUp,
            Self::ArrowDown,
            Self::ArrowLeft,
            Self::ArrowRight,
            Self::ArrowUp,
            Self::NumLock,
            Self::Numpad0,
            Self::Numpad1,
            Self::Numpad2,
            Self::Numpad3,
            Self::Numpad4,
            Self::Numpad5,
            Self::Numpad6,
            Self::Numpad7,
            Self::Numpad8,
            Self::Numpad9,
            Self::NumpadAdd,
            Self::NumpadBackspace,
            Self::NumpadClear,
            Self::NumpadClearEntry,
            Self::NumpadComma,
            Self::NumpadDecimal,
            Self::NumpadDivide,
            Self::NumpadEnter,
            Self::NumpadEqual,
            Self::NumpadHash,
            Self::NumpadMemoryAdd,
            Self::NumpadMemoryClear,
            Self::NumpadMemoryRecall,
            Self::NumpadMemoryStore,
            Self::NumpadMemorySubtract,
            Self::NumpadMultiply,
            Self::NumpadParenLeft,
            Self::NumpadParenRight,
            Self::NumpadStar,
            Self::NumpadSubtract,
            Self::Escape,
            Self::Fn,
            Self::FnLock,
            Self::PrintScreen,
            Self::ScrollLock,
            Self::Pause,
            Self::BrowserBack,
            Self::BrowserFavorites,
            Self::BrowserForward,
            Self::BrowserHome,
            Self::BrowserRefresh,
            Self::BrowserSearch,
            Self::BrowserStop,
            Self::Eject,
            Self::LaunchApp1,
            Self::LaunchApp2,
            Self::LaunchMail,
            Self::MediaPlayPause,
            Self::MediaSelect,
            Self::MediaStop,
            Self::MediaTrackNext,
            Self::MediaTrackPrevious,
            Self::Power,
            Self::Sleep,
            Self::AudioVolumeDown,
            Self::AudioVolumeMute,
            Self::AudioVolumeUp,
            Self::WakeUp,
            Self::Hyper,
            Self::Super,
            Self::Turbo,
            Self::Abort,
            Self::Resume,
            Self::Suspend,
            Self::Again,
            Self::Copy,
            Self::Cut,
            Self::Find,
            Self::Open,
            Self::Paste,
            Self::Props,
            Self::Select,
            Self::Undo,
            Self::Hiragana,
            Self::Katakana,
            Self::F1,
            Self::F2,
            Self::F3,
            Self::F4,
            Self::F5,
            Self::F6,
            Self::F7,
            Self::F8,
            Self::F9,
            Self::F10,
            Self::F11,
            Self::F12,
            Self::F13,
            Self::F14,
            Self::F15,
            Self::F16,
            Self::F17,
            Self::F18,
            Self::F19,
            Self::F20,
            Self::F21,
            Self::F22,
            Self::F23,
            Self::F24,
            Self::F25,
            Self::F26,
            Self::F27,
            Self::F28,
            Self::F29,
            Self::F30,
            Self::F31,
            Self::F32,
            Self::F33,
            Self::F34,
            Self::F35,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Backquote => Some("Backquote"),
                Self::Backslash => Some("Backslash"),
                Self::BracketLeft => Some("BracketLeft"),
                Self::BracketRight => Some("BracketRight"),
                Self::Comma => Some("Comma"),
                Self::Digit0 => Some("Digit0"),
                Self::Digit1 => Some("Digit1"),
                Self::Digit2 => Some("Digit2"),
                Self::Digit3 => Some("Digit3"),
                Self::Digit4 => Some("Digit4"),
                Self::Digit5 => Some("Digit5"),
                Self::Digit6 => Some("Digit6"),
                Self::Digit7 => Some("Digit7"),
                Self::Digit8 => Some("Digit8"),
                Self::Digit9 => Some("Digit9"),
                Self::Equal => Some("Equal"),
                Self::IntlBackslash => Some("IntlBackslash"),
                Self::IntlRo => Some("IntlRo"),
                Self::IntlYen => Some("IntlYen"),
                Self::KeyA => Some("KeyA"),
                Self::KeyB => Some("KeyB"),
                Self::KeyC => Some("KeyC"),
                Self::KeyD => Some("KeyD"),
                Self::KeyE => Some("KeyE"),
                Self::KeyF => Some("KeyF"),
                Self::KeyG => Some("KeyG"),
                Self::KeyH => Some("KeyH"),
                Self::KeyI => Some("KeyI"),
                Self::KeyJ => Some("KeyJ"),
                Self::KeyK => Some("KeyK"),
                Self::KeyL => Some("KeyL"),
                Self::KeyM => Some("KeyM"),
                Self::KeyN => Some("KeyN"),
                Self::KeyO => Some("KeyO"),
                Self::KeyP => Some("KeyP"),
                Self::KeyQ => Some("KeyQ"),
                Self::KeyR => Some("KeyR"),
                Self::KeyS => Some("KeyS"),
                Self::KeyT => Some("KeyT"),
                Self::KeyU => Some("KeyU"),
                Self::KeyV => Some("KeyV"),
                Self::KeyW => Some("KeyW"),
                Self::KeyX => Some("KeyX"),
                Self::KeyY => Some("KeyY"),
                Self::KeyZ => Some("KeyZ"),
                Self::Minus => Some("Minus"),
                Self::Period => Some("Period"),
                Self::Quote => Some("Quote"),
                Self::Semicolon => Some("Semicolon"),
                Self::Slash => Some("Slash"),
                Self::AltLeft => Some("AltLeft"),
                Self::AltRight => Some("AltRight"),
                Self::Backspace => Some("Backspace"),
                Self::CapsLock => Some("CapsLock"),
                Self::ContextMenu => Some("ContextMenu"),
                Self::ControlLeft => Some("ControlLeft"),
                Self::ControlRight => Some("ControlRight"),
                Self::Enter => Some("Enter"),
                Self::MetaLeft => Some("MetaLeft"),
                Self::MetaRight => Some("MetaRight"),
                Self::ShiftLeft => Some("ShiftLeft"),
                Self::ShiftRight => Some("ShiftRight"),
                Self::Space => Some("Space"),
                Self::Tab => Some("Tab"),
                Self::Convert => Some("Convert"),
                Self::KanaMode => Some("KanaMode"),
                Self::Lang1 => Some("Lang1"),
                Self::Lang2 => Some("Lang2"),
                Self::Lang3 => Some("Lang3"),
                Self::Lang4 => Some("Lang4"),
                Self::Lang5 => Some("Lang5"),
                Self::NonConvert => Some("NonConvert"),
                Self::Delete => Some("Delete"),
                Self::End => Some("End"),
                Self::Help => Some("Help"),
                Self::Home => Some("Home"),
                Self::Insert => Some("Insert"),
                Self::PageDown => Some("PageDown"),
                Self::PageUp => Some("PageUp"),
                Self::ArrowDown => Some("ArrowDown"),
                Self::ArrowLeft => Some("ArrowLeft"),
                Self::ArrowRight => Some("ArrowRight"),
                Self::ArrowUp => Some("ArrowUp"),
                Self::NumLock => Some("NumLock"),
                Self::Numpad0 => Some("Numpad0"),
                Self::Numpad1 => Some("Numpad1"),
                Self::Numpad2 => Some("Numpad2"),
                Self::Numpad3 => Some("Numpad3"),
                Self::Numpad4 => Some("Numpad4"),
                Self::Numpad5 => Some("Numpad5"),
                Self::Numpad6 => Some("Numpad6"),
                Self::Numpad7 => Some("Numpad7"),
                Self::Numpad8 => Some("Numpad8"),
                Self::Numpad9 => Some("Numpad9"),
                Self::NumpadAdd => Some("NumpadAdd"),
                Self::NumpadBackspace => Some("NumpadBackspace"),
                Self::NumpadClear => Some("NumpadClear"),
                Self::NumpadClearEntry => Some("NumpadClearEntry"),
                Self::NumpadComma => Some("NumpadComma"),
                Self::NumpadDecimal => Some("NumpadDecimal"),
                Self::NumpadDivide => Some("NumpadDivide"),
                Self::NumpadEnter => Some("NumpadEnter"),
                Self::NumpadEqual => Some("NumpadEqual"),
                Self::NumpadHash => Some("NumpadHash"),
                Self::NumpadMemoryAdd => Some("NumpadMemoryAdd"),
                Self::NumpadMemoryClear => Some("NumpadMemoryClear"),
                Self::NumpadMemoryRecall => Some("NumpadMemoryRecall"),
                Self::NumpadMemoryStore => Some("NumpadMemoryStore"),
                Self::NumpadMemorySubtract => Some("NumpadMemorySubtract"),
                Self::NumpadMultiply => Some("NumpadMultiply"),
                Self::NumpadParenLeft => Some("NumpadParenLeft"),
                Self::NumpadParenRight => Some("NumpadParenRight"),
                Self::NumpadStar => Some("NumpadStar"),
                Self::NumpadSubtract => Some("NumpadSubtract"),
                Self::Escape => Some("Escape"),
                Self::Fn => Some("Fn"),
                Self::FnLock => Some("FnLock"),
                Self::PrintScreen => Some("PrintScreen"),
                Self::ScrollLock => Some("ScrollLock"),
                Self::Pause => Some("Pause"),
                Self::BrowserBack => Some("BrowserBack"),
                Self::BrowserFavorites => Some("BrowserFavorites"),
                Self::BrowserForward => Some("BrowserForward"),
                Self::BrowserHome => Some("BrowserHome"),
                Self::BrowserRefresh => Some("BrowserRefresh"),
                Self::BrowserSearch => Some("BrowserSearch"),
                Self::BrowserStop => Some("BrowserStop"),
                Self::Eject => Some("Eject"),
                Self::LaunchApp1 => Some("LaunchApp1"),
                Self::LaunchApp2 => Some("LaunchApp2"),
                Self::LaunchMail => Some("LaunchMail"),
                Self::MediaPlayPause => Some("MediaPlayPause"),
                Self::MediaSelect => Some("MediaSelect"),
                Self::MediaStop => Some("MediaStop"),
                Self::MediaTrackNext => Some("MediaTrackNext"),
                Self::MediaTrackPrevious => Some("MediaTrackPrevious"),
                Self::Power => Some("Power"),
                Self::Sleep => Some("Sleep"),
                Self::AudioVolumeDown => Some("AudioVolumeDown"),
                Self::AudioVolumeMute => Some("AudioVolumeMute"),
                Self::AudioVolumeUp => Some("AudioVolumeUp"),
                Self::WakeUp => Some("WakeUp"),
                Self::Hyper => Some("Hyper"),
                Self::Super => Some("Super"),
                Self::Turbo => Some("Turbo"),
                Self::Abort => Some("Abort"),
                Self::Resume => Some("Resume"),
                Self::Suspend => Some("Suspend"),
                Self::Again => Some("Again"),
                Self::Copy => Some("Copy"),
                Self::Cut => Some("Cut"),
                Self::Find => Some("Find"),
                Self::Open => Some("Open"),
                Self::Paste => Some("Paste"),
                Self::Props => Some("Props"),
                Self::Select => Some("Select"),
                Self::Undo => Some("Undo"),
                Self::Hiragana => Some("Hiragana"),
                Self::Katakana => Some("Katakana"),
                Self::F1 => Some("F1"),
                Self::F2 => Some("F2"),
                Self::F3 => Some("F3"),
                Self::F4 => Some("F4"),
                Self::F5 => Some("F5"),
                Self::F6 => Some("F6"),
                Self::F7 => Some("F7"),
                Self::F8 => Some("F8"),
                Self::F9 => Some("F9"),
                Self::F10 => Some("F10"),
                Self::F11 => Some("F11"),
                Self::F12 => Some("F12"),
                Self::F13 => Some("F13"),
                Self::F14 => Some("F14"),
                Self::F15 => Some("F15"),
                Self::F16 => Some("F16"),
                Self::F17 => Some("F17"),
                Self::F18 => Some("F18"),
                Self::F19 => Some("F19"),
                Self::F20 => Some("F20"),
                Self::F21 => Some("F21"),
                Self::F22 => Some("F22"),
                Self::F23 => Some("F23"),
                Self::F24 => Some("F24"),
                Self::F25 => Some("F25"),
                Self::F26 => Some("F26"),
                Self::F27 => Some("F27"),
                Self::F28 => Some("F28"),
                Self::F29 => Some("F29"),
                Self::F30 => Some("F30"),
                Self::F31 => Some("F31"),
                Self::F32 => Some("F32"),
                Self::F33 => Some("F33"),
                Self::F34 => Some("F34"),
                Self::F35 => Some("F35"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for KeyCode {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for KeyCode {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for KeyCode {
        type Output = KeyCode;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for KeyCode {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for KeyCode {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for KeyCode {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ELEMENT_STATE: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ELEMENT_STATE: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ELEMENT_STATE: [ElementState; 2] =
        [ElementState::Pressed, ElementState::Released];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ElementState(pub u8);
    #[allow(non_upper_case_globals)]
    impl ElementState {
        pub const Pressed: Self = Self(0);
        pub const Released: Self = Self(1);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Pressed, Self::Released];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Pressed => Some("Pressed"),
                Self::Released => Some("Released"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ElementState {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ElementState {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ElementState {
        type Output = ElementState;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ElementState {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ElementState {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ElementState {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MOUSE_BUTTON: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MOUSE_BUTTON: u8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MOUSE_BUTTON: [MouseButton; 3] =
        [MouseButton::Left, MouseButton::Right, MouseButton::Middle];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MouseButton(pub u8);
    #[allow(non_upper_case_globals)]
    impl MouseButton {
        pub const Left: Self = Self(0);
        pub const Right: Self = Self(1);
        pub const Middle: Self = Self(2);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::Left, Self::Right, Self::Middle];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::Left => Some("Left"),
                Self::Right => Some("Right"),
                Self::Middle => Some("Middle"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for MouseButton {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MouseButton {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for MouseButton {
        type Output = MouseButton;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for MouseButton {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MouseButton {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MouseButton {}
    // struct KeyboardInput, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct KeyboardInput(pub [u8; 2]);
    impl Default for KeyboardInput {
        fn default() -> Self {
            Self([0; 2])
        }
    }
    impl core::fmt::Debug for KeyboardInput {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("KeyboardInput")
                .field("key_code", &self.key_code())
                .field("state", &self.state())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for KeyboardInput {}
    impl<'a> flatbuffers::Follow<'a> for KeyboardInput {
        type Inner = &'a KeyboardInput;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a KeyboardInput>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a KeyboardInput {
        type Inner = &'a KeyboardInput;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<KeyboardInput>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for KeyboardInput {
        type Output = KeyboardInput;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const KeyboardInput as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for KeyboardInput {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> KeyboardInput {
        #[allow(clippy::too_many_arguments)]
        pub fn new(key_code: KeyCode, state: ElementState) -> Self {
            let mut s = Self([0; 2]);
            s.set_key_code(key_code);
            s.set_state(state);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.KeyboardInput"
        }

        pub fn key_code(&self) -> KeyCode {
            let mut mem = core::mem::MaybeUninit::<<KeyCode as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<KeyCode as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_key_code(&mut self, x: KeyCode) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<KeyCode as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn state(&self) -> ElementState {
            let mut mem =
                core::mem::MaybeUninit::<<ElementState as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[1..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<ElementState as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_state(&mut self, x: ElementState) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[1..].as_mut_ptr(),
                    core::mem::size_of::<<ElementState as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> KeyboardInputT {
            KeyboardInputT {
                key_code: self.key_code(),
                state: self.state(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct KeyboardInputT {
        pub key_code: KeyCode,
        pub state: ElementState,
    }
    impl KeyboardInputT {
        pub fn pack(&self) -> KeyboardInput {
            KeyboardInput::new(self.key_code, self.state)
        }
    }

    // struct MousePosition, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct MousePosition(pub [u8; 8]);
    impl Default for MousePosition {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for MousePosition {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("MousePosition")
                .field("x", &self.x())
                .field("y", &self.y())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MousePosition {}
    impl<'a> flatbuffers::Follow<'a> for MousePosition {
        type Inner = &'a MousePosition;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a MousePosition>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a MousePosition {
        type Inner = &'a MousePosition;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<MousePosition>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for MousePosition {
        type Output = MousePosition;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const MousePosition as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for MousePosition {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> MousePosition {
        #[allow(clippy::too_many_arguments)]
        pub fn new(x: f32, y: f32) -> Self {
            let mut s = Self([0; 8]);
            s.set_x(x);
            s.set_y(y);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.MousePosition"
        }

        pub fn x(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_x(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn y(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_y(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> MousePositionT {
            MousePositionT {
                x: self.x(),
                y: self.y(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct MousePositionT {
        pub x: f32,
        pub y: f32,
    }
    impl MousePositionT {
        pub fn pack(&self) -> MousePosition {
            MousePosition::new(self.x, self.y)
        }
    }

    // struct MouseButtonInput, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct MouseButtonInput(pub [u8; 2]);
    impl Default for MouseButtonInput {
        fn default() -> Self {
            Self([0; 2])
        }
    }
    impl core::fmt::Debug for MouseButtonInput {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("MouseButtonInput")
                .field("button", &self.button())
                .field("state", &self.state())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MouseButtonInput {}
    impl<'a> flatbuffers::Follow<'a> for MouseButtonInput {
        type Inner = &'a MouseButtonInput;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a MouseButtonInput>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a MouseButtonInput {
        type Inner = &'a MouseButtonInput;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<MouseButtonInput>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for MouseButtonInput {
        type Output = MouseButtonInput;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const MouseButtonInput as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for MouseButtonInput {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> MouseButtonInput {
        #[allow(clippy::too_many_arguments)]
        pub fn new(button: MouseButton, state: ElementState) -> Self {
            let mut s = Self([0; 2]);
            s.set_button(button);
            s.set_state(state);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.MouseButtonInput"
        }

        pub fn button(&self) -> MouseButton {
            let mut mem = core::mem::MaybeUninit::<<MouseButton as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<MouseButton as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_button(&mut self, x: MouseButton) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<MouseButton as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn state(&self) -> ElementState {
            let mut mem =
                core::mem::MaybeUninit::<<ElementState as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[1..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<ElementState as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_state(&mut self, x: ElementState) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[1..].as_mut_ptr(),
                    core::mem::size_of::<<ElementState as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> MouseButtonInputT {
            MouseButtonInputT {
                button: self.button(),
                state: self.state(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct MouseButtonInputT {
        pub button: MouseButton,
        pub state: ElementState,
    }
    impl MouseButtonInputT {
        pub fn pack(&self) -> MouseButtonInput {
            MouseButtonInput::new(self.button, self.state)
        }
    }

    // struct MouseScroll, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct MouseScroll(pub [u8; 8]);
    impl Default for MouseScroll {
        fn default() -> Self {
            Self([0; 8])
        }
    }
    impl core::fmt::Debug for MouseScroll {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("MouseScroll")
                .field("x", &self.x())
                .field("y", &self.y())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MouseScroll {}
    impl<'a> flatbuffers::Follow<'a> for MouseScroll {
        type Inner = &'a MouseScroll;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a MouseScroll>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a MouseScroll {
        type Inner = &'a MouseScroll;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<MouseScroll>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for MouseScroll {
        type Output = MouseScroll;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const MouseScroll as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for MouseScroll {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> MouseScroll {
        #[allow(clippy::too_many_arguments)]
        pub fn new(x: f32, y: f32) -> Self {
            let mut s = Self([0; 8]);
            s.set_x(x);
            s.set_y(y);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.MouseScroll"
        }

        pub fn x(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_x(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn y(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_y(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> MouseScrollT {
            MouseScrollT {
                x: self.x(),
                y: self.y(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct MouseScrollT {
        pub x: f32,
        pub y: f32,
    }
    impl MouseScrollT {
        pub fn pack(&self) -> MouseScroll {
            MouseScroll::new(self.x, self.y)
        }
    }

    // struct GamepadDisconnected, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct GamepadDisconnected(pub [u8; 4]);
    impl Default for GamepadDisconnected {
        fn default() -> Self {
            Self([0; 4])
        }
    }
    impl core::fmt::Debug for GamepadDisconnected {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("GamepadDisconnected")
                .field("id", &self.id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for GamepadDisconnected {}
    impl<'a> flatbuffers::Follow<'a> for GamepadDisconnected {
        type Inner = &'a GamepadDisconnected;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a GamepadDisconnected>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a GamepadDisconnected {
        type Inner = &'a GamepadDisconnected;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<GamepadDisconnected>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for GamepadDisconnected {
        type Output = GamepadDisconnected;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const GamepadDisconnected as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for GamepadDisconnected {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> GamepadDisconnected {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: u32) -> Self {
            let mut s = Self([0; 4]);
            s.set_id(id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.GamepadDisconnected"
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> GamepadDisconnectedT {
            GamepadDisconnectedT { id: self.id() }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct GamepadDisconnectedT {
        pub id: u32,
    }
    impl GamepadDisconnectedT {
        pub fn pack(&self) -> GamepadDisconnected {
            GamepadDisconnected::new(self.id)
        }
    }

    // struct GamepadButton, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct GamepadButton(pub [u8; 12]);
    impl Default for GamepadButton {
        fn default() -> Self {
            Self([0; 12])
        }
    }
    impl core::fmt::Debug for GamepadButton {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("GamepadButton")
                .field("id", &self.id())
                .field("index", &self.index())
                .field("value", &self.value())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for GamepadButton {}
    impl<'a> flatbuffers::Follow<'a> for GamepadButton {
        type Inner = &'a GamepadButton;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a GamepadButton>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a GamepadButton {
        type Inner = &'a GamepadButton;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<GamepadButton>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for GamepadButton {
        type Output = GamepadButton;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const GamepadButton as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for GamepadButton {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> GamepadButton {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: u32, index: u32, value: f32) -> Self {
            let mut s = Self([0; 12]);
            s.set_id(id);
            s.set_index(index);
            s.set_value(value);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.GamepadButton"
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn index(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_index(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn value(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_value(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> GamepadButtonT {
            GamepadButtonT {
                id: self.id(),
                index: self.index(),
                value: self.value(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct GamepadButtonT {
        pub id: u32,
        pub index: u32,
        pub value: f32,
    }
    impl GamepadButtonT {
        pub fn pack(&self) -> GamepadButton {
            GamepadButton::new(self.id, self.index, self.value)
        }
    }

    // struct GamepadAxis, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct GamepadAxis(pub [u8; 12]);
    impl Default for GamepadAxis {
        fn default() -> Self {
            Self([0; 12])
        }
    }
    impl core::fmt::Debug for GamepadAxis {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("GamepadAxis")
                .field("id", &self.id())
                .field("index", &self.index())
                .field("value", &self.value())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for GamepadAxis {}
    impl<'a> flatbuffers::Follow<'a> for GamepadAxis {
        type Inner = &'a GamepadAxis;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a GamepadAxis>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a GamepadAxis {
        type Inner = &'a GamepadAxis;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<GamepadAxis>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for GamepadAxis {
        type Output = GamepadAxis;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const GamepadAxis as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for GamepadAxis {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> GamepadAxis {
        #[allow(clippy::too_many_arguments)]
        pub fn new(id: u32, index: u32, value: f32) -> Self {
            let mut s = Self([0; 12]);
            s.set_id(id);
            s.set_index(index);
            s.set_value(value);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.GamepadAxis"
        }

        pub fn id(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_id(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn index(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_index(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn value(&self) -> f32 {
            let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_value(&mut self, x: f32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> GamepadAxisT {
            GamepadAxisT {
                id: self.id(),
                index: self.index(),
                value: self.value(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct GamepadAxisT {
        pub id: u32,
        pub index: u32,
        pub value: f32,
    }
    impl GamepadAxisT {
        pub fn pack(&self) -> GamepadAxis {
            GamepadAxis::new(self.id, self.index, self.value)
        }
    }

    // struct WindowResized, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct WindowResized(pub [u8; 12]);
    impl Default for WindowResized {
        fn default() -> Self {
            Self([0; 12])
        }
    }
    impl core::fmt::Debug for WindowResized {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("WindowResized")
                .field("width", &self.width())
                .field("height", &self.height())
                .field("update_aspect", &self.update_aspect())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for WindowResized {}
    impl<'a> flatbuffers::Follow<'a> for WindowResized {
        type Inner = &'a WindowResized;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a WindowResized>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a WindowResized {
        type Inner = &'a WindowResized;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<WindowResized>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for WindowResized {
        type Output = WindowResized;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const WindowResized as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for WindowResized {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> WindowResized {
        #[allow(clippy::too_many_arguments)]
        pub fn new(width: u32, height: u32, update_aspect: bool) -> Self {
            let mut s = Self([0; 12]);
            s.set_width(width);
            s.set_height(height);
            s.set_update_aspect(update_aspect);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.WindowResized"
        }

        pub fn width(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_width(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn height(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[4..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_height(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[4..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        /// If `true`, the `Aspect` resource will be updated to match the new window
        /// size. This should be `true` for most platforms.
        pub fn update_aspect(&self) -> bool {
            let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[8..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_update_aspect(&mut self, x: bool) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[8..].as_mut_ptr(),
                    core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> WindowResizedT {
            WindowResizedT {
                width: self.width(),
                height: self.height(),
                update_aspect: self.update_aspect(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct WindowResizedT {
        pub width: u32,
        pub height: u32,
        pub update_aspect: bool,
    }
    impl WindowResizedT {
        pub fn pack(&self) -> WindowResized {
            WindowResized::new(self.width, self.height, self.update_aspect)
        }
    }

    // struct WindowFocused, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct WindowFocused(pub [u8; 1]);
    impl Default for WindowFocused {
        fn default() -> Self {
            Self([0; 1])
        }
    }
    impl core::fmt::Debug for WindowFocused {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("WindowFocused")
                .field("window_id", &self.window_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for WindowFocused {}
    impl<'a> flatbuffers::Follow<'a> for WindowFocused {
        type Inner = &'a WindowFocused;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a WindowFocused>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a WindowFocused {
        type Inner = &'a WindowFocused;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<WindowFocused>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for WindowFocused {
        type Output = WindowFocused;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const WindowFocused as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for WindowFocused {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> WindowFocused {
        #[allow(clippy::too_many_arguments)]
        pub fn new(window_id: u8) -> Self {
            let mut s = Self([0; 1]);
            s.set_window_id(window_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.WindowFocused"
        }

        pub fn window_id(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_window_id(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> WindowFocusedT {
            WindowFocusedT {
                window_id: self.window_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct WindowFocusedT {
        pub window_id: u8,
    }
    impl WindowFocusedT {
        pub fn pack(&self) -> WindowFocused {
            WindowFocused::new(self.window_id)
        }
    }

    // struct WindowUnfocused, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct WindowUnfocused(pub [u8; 1]);
    impl Default for WindowUnfocused {
        fn default() -> Self {
            Self([0; 1])
        }
    }
    impl core::fmt::Debug for WindowUnfocused {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("WindowUnfocused")
                .field("window_id", &self.window_id())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for WindowUnfocused {}
    impl<'a> flatbuffers::Follow<'a> for WindowUnfocused {
        type Inner = &'a WindowUnfocused;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a WindowUnfocused>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a WindowUnfocused {
        type Inner = &'a WindowUnfocused;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<WindowUnfocused>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for WindowUnfocused {
        type Output = WindowUnfocused;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const WindowUnfocused as *const u8,
                Self::size(),
            );
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for WindowUnfocused {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> WindowUnfocused {
        #[allow(clippy::too_many_arguments)]
        pub fn new(window_id: u8) -> Self {
            let mut s = Self([0; 1]);
            s.set_window_id(window_id);
            s
        }

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.WindowUnfocused"
        }

        pub fn window_id(&self) -> u8 {
            let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_window_id(&mut self, x: u8) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn unpack(&self) -> WindowUnfocusedT {
            WindowUnfocusedT {
                window_id: self.window_id(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct WindowUnfocusedT {
        pub window_id: u8,
    }
    impl WindowUnfocusedT {
        pub fn pack(&self) -> WindowUnfocused {
            WindowUnfocused::new(self.window_id)
        }
    }

    pub enum GamepadConnectedOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GamepadConnected<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GamepadConnected<'a> {
        type Inner = GamepadConnected<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GamepadConnected<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_BUTTON_COUNT: flatbuffers::VOffsetT = 6;
        pub const VT_AXIS_COUNT: flatbuffers::VOffsetT = 8;
        pub const VT_NAME: flatbuffers::VOffsetT = 10;

        pub const fn get_fully_qualified_name() -> &'static str {
            "Input.GamepadConnected"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GamepadConnected { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args GamepadConnectedArgs<'args>,
        ) -> flatbuffers::WIPOffset<GamepadConnected<'bldr>> {
            let mut builder = GamepadConnectedBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_axis_count(args.axis_count);
            builder.add_button_count(args.button_count);
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> GamepadConnectedT {
            let id = self.id();
            let button_count = self.button_count();
            let axis_count = self.axis_count();
            let name = self.name().map(|x| x.to_string());
            GamepadConnectedT {
                id,
                button_count,
                axis_count,
                name,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(GamepadConnected::VT_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn button_count(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(GamepadConnected::VT_BUTTON_COUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn axis_count(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(GamepadConnected::VT_AXIS_COUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(GamepadConnected::VT_NAME, None)
            }
        }
    }

    impl flatbuffers::Verifiable for GamepadConnected<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u32>("button_count", Self::VT_BUTTON_COUNT, false)?
                .visit_field::<u32>("axis_count", Self::VT_AXIS_COUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct GamepadConnectedArgs<'a> {
        pub id: u32,
        pub button_count: u32,
        pub axis_count: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for GamepadConnectedArgs<'a> {
        #[inline]
        fn default() -> Self {
            GamepadConnectedArgs {
                id: 0,
                button_count: 0,
                axis_count: 0,
                name: None,
            }
        }
    }

    pub struct GamepadConnectedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GamepadConnectedBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(GamepadConnected::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_button_count(&mut self, button_count: u32) {
            self.fbb_
                .push_slot::<u32>(GamepadConnected::VT_BUTTON_COUNT, button_count, 0);
        }
        #[inline]
        pub fn add_axis_count(&mut self, axis_count: u32) {
            self.fbb_
                .push_slot::<u32>(GamepadConnected::VT_AXIS_COUNT, axis_count, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(GamepadConnected::VT_NAME, name);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> GamepadConnectedBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            GamepadConnectedBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GamepadConnected<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GamepadConnected<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GamepadConnected");
            ds.field("id", &self.id());
            ds.field("button_count", &self.button_count());
            ds.field("axis_count", &self.axis_count());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct GamepadConnectedT {
        pub id: u32,
        pub button_count: u32,
        pub axis_count: u32,
        pub name: Option<String>,
    }
    impl Default for GamepadConnectedT {
        fn default() -> Self {
            Self {
                id: 0,
                button_count: 0,
                axis_count: 0,
                name: None,
            }
        }
    }
    impl GamepadConnectedT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<GamepadConnected<'b>> {
            let id = self.id;
            let button_count = self.button_count;
            let axis_count = self.axis_count;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            GamepadConnected::create(
                _fbb,
                &GamepadConnectedArgs {
                    id,
                    button_count,
                    axis_count,
                    name,
                },
            )
        }
    }
} // pub mod Input

#[allow(unused_imports, dead_code)]
pub mod particle_effects {

    use core::{cmp::Ordering, mem};

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum SpawnParticleEffectOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SpawnParticleEffect<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SpawnParticleEffect<'a> {
        type Inner = SpawnParticleEffect<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SpawnParticleEffect<'a> {
        pub const VT_HANDLE: flatbuffers::VOffsetT = 4;
        pub const VT_DESCRIPTOR_ASSET_ID: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "ParticleEffects.SpawnParticleEffect"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SpawnParticleEffect { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SpawnParticleEffectArgs,
        ) -> flatbuffers::WIPOffset<SpawnParticleEffect<'bldr>> {
            let mut builder = SpawnParticleEffectBuilder::new(_fbb);
            builder.add_handle(args.handle);
            builder.add_descriptor_asset_id(args.descriptor_asset_id);
            builder.finish()
        }

        pub fn unpack(&self) -> SpawnParticleEffectT {
            let handle = self.handle();
            let descriptor_asset_id = self.descriptor_asset_id();
            SpawnParticleEffectT {
                handle,
                descriptor_asset_id,
            }
        }

        #[inline]
        pub fn handle(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SpawnParticleEffect::VT_HANDLE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn descriptor_asset_id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(SpawnParticleEffect::VT_DESCRIPTOR_ASSET_ID, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SpawnParticleEffect<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("handle", Self::VT_HANDLE, false)?
                .visit_field::<u32>("descriptor_asset_id", Self::VT_DESCRIPTOR_ASSET_ID, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpawnParticleEffectArgs {
        pub handle: u64,
        pub descriptor_asset_id: u32,
    }
    impl<'a> Default for SpawnParticleEffectArgs {
        #[inline]
        fn default() -> Self {
            SpawnParticleEffectArgs {
                handle: 0,
                descriptor_asset_id: 0,
            }
        }
    }

    pub struct SpawnParticleEffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SpawnParticleEffectBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_handle(&mut self, handle: u64) {
            self.fbb_
                .push_slot::<u64>(SpawnParticleEffect::VT_HANDLE, handle, 0);
        }
        #[inline]
        pub fn add_descriptor_asset_id(&mut self, descriptor_asset_id: u32) {
            self.fbb_.push_slot::<u32>(
                SpawnParticleEffect::VT_DESCRIPTOR_ASSET_ID,
                descriptor_asset_id,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SpawnParticleEffectBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SpawnParticleEffectBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SpawnParticleEffect<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SpawnParticleEffect<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SpawnParticleEffect");
            ds.field("handle", &self.handle());
            ds.field("descriptor_asset_id", &self.descriptor_asset_id());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SpawnParticleEffectT {
        pub handle: u64,
        pub descriptor_asset_id: u32,
    }
    impl Default for SpawnParticleEffectT {
        fn default() -> Self {
            Self {
                handle: 0,
                descriptor_asset_id: 0,
            }
        }
    }
    impl SpawnParticleEffectT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SpawnParticleEffect<'b>> {
            let handle = self.handle;
            let descriptor_asset_id = self.descriptor_asset_id;
            SpawnParticleEffect::create(
                _fbb,
                &SpawnParticleEffectArgs {
                    handle,
                    descriptor_asset_id,
                },
            )
        }
    }
    pub enum DespawnParticleEffectOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DespawnParticleEffect<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DespawnParticleEffect<'a> {
        type Inner = DespawnParticleEffect<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DespawnParticleEffect<'a> {
        pub const VT_HANDLE: flatbuffers::VOffsetT = 4;

        pub const fn get_fully_qualified_name() -> &'static str {
            "ParticleEffects.DespawnParticleEffect"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DespawnParticleEffect { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args DespawnParticleEffectArgs,
        ) -> flatbuffers::WIPOffset<DespawnParticleEffect<'bldr>> {
            let mut builder = DespawnParticleEffectBuilder::new(_fbb);
            builder.add_handle(args.handle);
            builder.finish()
        }

        pub fn unpack(&self) -> DespawnParticleEffectT {
            let handle = self.handle();
            DespawnParticleEffectT { handle }
        }

        #[inline]
        pub fn handle(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(DespawnParticleEffect::VT_HANDLE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DespawnParticleEffect<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("handle", Self::VT_HANDLE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DespawnParticleEffectArgs {
        pub handle: u64,
    }
    impl<'a> Default for DespawnParticleEffectArgs {
        #[inline]
        fn default() -> Self {
            DespawnParticleEffectArgs { handle: 0 }
        }
    }

    pub struct DespawnParticleEffectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DespawnParticleEffectBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_handle(&mut self, handle: u64) {
            self.fbb_
                .push_slot::<u64>(DespawnParticleEffect::VT_HANDLE, handle, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> DespawnParticleEffectBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            DespawnParticleEffectBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DespawnParticleEffect<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DespawnParticleEffect<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DespawnParticleEffect");
            ds.field("handle", &self.handle());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct DespawnParticleEffectT {
        pub handle: u64,
    }
    impl Default for DespawnParticleEffectT {
        fn default() -> Self {
            Self { handle: 0 }
        }
    }
    impl DespawnParticleEffectT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<DespawnParticleEffect<'b>> {
            let handle = self.handle;
            DespawnParticleEffect::create(_fbb, &DespawnParticleEffectArgs { handle })
        }
    }
    pub enum SetParticleEffectTransformOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SetParticleEffectTransform<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SetParticleEffectTransform<'a> {
        type Inner = SetParticleEffectTransform<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SetParticleEffectTransform<'a> {
        pub const VT_HANDLE: flatbuffers::VOffsetT = 4;
        pub const VT_TRANSFORM: flatbuffers::VOffsetT = 6;

        pub const fn get_fully_qualified_name() -> &'static str {
            "ParticleEffects.SetParticleEffectTransform"
        }

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SetParticleEffectTransform { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SetParticleEffectTransformArgs<'args>,
        ) -> flatbuffers::WIPOffset<SetParticleEffectTransform<'bldr>> {
            let mut builder = SetParticleEffectTransformBuilder::new(_fbb);
            builder.add_handle(args.handle);
            if let Some(x) = args.transform {
                builder.add_transform(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SetParticleEffectTransformT {
            let handle = self.handle();
            let transform = self.transform().map(|x| x.unpack());
            SetParticleEffectTransformT { handle, transform }
        }

        #[inline]
        pub fn handle(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SetParticleEffectTransform::VT_HANDLE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn transform(&self) -> Option<&'a super::Transform> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<super::Transform>(SetParticleEffectTransform::VT_TRANSFORM, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SetParticleEffectTransform<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("handle", Self::VT_HANDLE, false)?
                .visit_field::<super::Transform>("transform", Self::VT_TRANSFORM, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SetParticleEffectTransformArgs<'a> {
        pub handle: u64,
        pub transform: Option<&'a super::Transform>,
    }
    impl<'a> Default for SetParticleEffectTransformArgs<'a> {
        #[inline]
        fn default() -> Self {
            SetParticleEffectTransformArgs {
                handle: 0,
                transform: None,
            }
        }
    }

    pub struct SetParticleEffectTransformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetParticleEffectTransformBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_handle(&mut self, handle: u64) {
            self.fbb_
                .push_slot::<u64>(SetParticleEffectTransform::VT_HANDLE, handle, 0);
        }
        #[inline]
        pub fn add_transform(&mut self, transform: &super::Transform) {
            self.fbb_.push_slot_always::<&super::Transform>(
                SetParticleEffectTransform::VT_TRANSFORM,
                transform,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SetParticleEffectTransformBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SetParticleEffectTransformBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SetParticleEffectTransform<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SetParticleEffectTransform<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SetParticleEffectTransform");
            ds.field("handle", &self.handle());
            ds.field("transform", &self.transform());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SetParticleEffectTransformT {
        pub handle: u64,
        pub transform: Option<super::TransformT>,
    }
    impl Default for SetParticleEffectTransformT {
        fn default() -> Self {
            Self {
                handle: 0,
                transform: None,
            }
        }
    }
    impl SetParticleEffectTransformT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<SetParticleEffectTransform<'b>> {
            let handle = self.handle;
            let transform_tmp = self.transform.as_ref().map(|x| x.pack());
            let transform = transform_tmp.as_ref();
            SetParticleEffectTransform::create(
                _fbb,
                &SetParticleEffectTransformArgs { handle, transform },
            )
        }
    }
} // pub mod ParticleEffects
