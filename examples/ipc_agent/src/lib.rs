//! An example of an IPC Agent module.
//!
//! See [`//modules/ipc/README.md`] for information on the IPC extension.
//!
//! This is a simple example. It's not intended to show every feature or stress
//! test the IPC messaging. It does illustrate the message passing in action and
//! is something you can start from to build your own (and much better) module.

// Required for `EventReader` and `EventWriter`.
#![allow(clippy::needless_pass_by_value)]

use std::io::{BufWriter, Write};

use game_module_macro::{system, system_once, ResourceWithoutSerialize};
use void_public::{Aspect, ComponentId, EcsType, EventReader, EventWriter, Resource};

pub mod event {
    #![allow(clippy::all, clippy::pedantic, warnings, unused, unused_imports)]
    include!(concat!(env!("OUT_DIR"), "/ipc_generated.rs"));
}
use event::{
    Close, Closed, MessageFromRemote, MessageToRemote, MessageToRemoteArgs, Opened, PortIgnore,
    PortIgnoreArgs, PortListen, PortListenArgs, PortListenResult,
};

pub mod ffi {
    #![allow(clippy::all, clippy::pedantic, warnings, unused, unused_imports)]
    use super::*;

    // A collection of C repr versions of the resources and systems in this file.
    // Generated by "../build.rs".
    include!(concat!(env!("OUT_DIR"), "/ffi.rs"));
}

/// The user ID helps us know who the messages are addressed to. (So an
/// arbitrary string would work as long as it's unique within a given game).
///
/// The events are broadcast, so if two modules ask to listen on the same port
/// at the same time, something is required to determine to whom the response is
/// going to (one may work and the other may fail, likely because the first one
/// succeeded).
///
/// This value should be unique among the modules in the game. The cargo package
/// name is likely to be unique, but if it's not, be sure to choose some other
/// string which is unique.
const AGENT_USER_ID: &str = env!("CARGO_PKG_NAME");

/// If this were a real game module and not just an example, it may help to keep
/// track of some state.
///
/// This (somewhat pointlessly, since the values are hard-coded) stores some
/// values in a resource to provide an example of storing state.
#[derive(Default, ResourceWithoutSerialize)]
struct AgentState {
    /// The TCP/IP port we intend to listen on.
    port: u16,

    /// A unique value for this module.
    user_id: String,

    /// Each connection receives a number which is used to address messages
    /// to/from that connection.
    ///
    /// If this module receives an event with a different channel number, it
    /// should be ignored (as it is not addressed to this module).
    ///
    /// Until a connection is established (and after it closes), this value will
    /// be None.
    ///
    /// Exercises:
    /// - (intermediate) This example handles only one channel at a time. Allow
    ///   for multiple connections to be made. Tip: Maybe a `HashMap` or similar
    ///   lookup keyed by connection channel number, to data about that
    ///   connection.
    channel: Option<u16>,
}

/// At startup of the game, an event is broadcast which asks for someone (the
/// IPC Host in this case) to listen on a TCP port number for new WebSocket
/// connections.
///
/// Exercises:
/// - (easy) Try different port numbers. Do some work better than others.
/// - (easy) Read about reserved port number ranges for TCP/IP (i.e. internet
///   search).
#[system_once]
fn init_agent(agent_state: &mut AgentState, port_listen_writer: EventWriter<PortListen<'_>>) {
    agent_state.port = 9001;
    agent_state.user_id = AGENT_USER_ID.to_string();
    println!(
        "IPC module {} listening on port {}",
        agent_state.user_id, agent_state.port,
    );
    port_listen_writer.write_builder(|builder| {
        let user_id_offset = Some(builder.create_string(&agent_state.user_id));
        PortListen::create(
            builder,
            &PortListenArgs {
                port: agent_state.port,
                user_id: user_id_offset,
            },
        )
    });
}

#[system]
fn handle_port_listen_result_events(reader: EventReader<PortListenResult<'_>>) {
    for event in &reader {
        println!("IPC Agent: received event {:?}", event);
        if event.user_id() == Some(AGENT_USER_ID) {
            // If we wanted to take some action upon successfully listening at a
            // websocket port, this is the place to do it.
            //
            // If the user id did not match our user id, then the event should
            // be ignored.
        }
    }
}

/// This system processes events of type `Opened`, which is one of the message
/// types defined by the IPC module.
///
/// Exercises:
/// - (easy) Separating handling of different events is good practice, but
///   imagine you wanted to combine `handle_opened_events` and
///   `handle_closed_events`. Try doing so. Is it easier or harder to read or
///   reason about the code?
/// - (intermediate) This example correctly filters open events which are
///   intended for this module, but it only allows for one connection. What
///   should happen if another connection is already present (other than panic
///   from the assert below)? Tip: notice the `_close_writer` provided.
#[system]
fn handle_opened_events(
    agent_state: &mut AgentState,
    reader: EventReader<Opened<'_>>,
    _close_writer: EventWriter<Close>,
) {
    for event in &reader {
        println!("IPC Agent: received event {:?}", event);
        if event.user_id() == Some(AGENT_USER_ID) {
            // This example agent only expects one connection (channel) at a
            // time.
            assert!(agent_state.channel.is_none());
            agent_state.channel = Some(event.channel());
        }
    }
}

/// Find out if we should stop processing events for a connection.
///
/// Exercises:
/// - (easy) Consider or experiment with not setting the `agent_state.channel`
///   to None. What issues may arise?
#[system]
fn handle_closed_events(agent_state: &mut AgentState, reader: EventReader<Closed>) {
    for event in &reader {
        println!("IPC Agent: received event {:?}", event);
        if let Some(channel) = agent_state.channel {
            // Only process this event if it is from our channel (otherwise it
            // should be ignored).
            if channel == event.channel() {
                // From now on, ignore messages on the channel.
                agent_state.channel = None;
            }
        }
    }
}

/// `MessageFromRemote` are messages coming from a remote process on an `Opened`
/// connection (through the IPC Host module, which acts like a currier).
///
/// This example also shows messages being written to the remote process using
/// and `EventWriter` of type `MessageToRemote`.
///
/// Exercises:
/// - (easy) Process different `kind` of messages by printing different
///   messages.
/// - (intermediate) Cause changes to the game based on different messages
///   ('kind'). Tip: Maybe mix this example with the moving-box example and
///   change the speed or color of the moving shape.
/// - (intermediate) Define your own message format. This can be as simple as
///   changing the `kind` to another type, maybe a u16; or as involved as you
///   like (maybe define `FlatBuffers` for the messages).
#[system]
fn handle_message_events(
    aspect: &Aspect,
    agent_state: &mut AgentState,
    reader: EventReader<MessageFromRemote<'_>>,
    writer: EventWriter<MessageToRemote<'_>>,
    _close_writer: EventWriter<Close>,
    port_ignore_writer: EventWriter<PortIgnore<'_>>,
) {
    for event in &reader {
        println!(
            "IPC Agent: received event {:?}, our channel is {:?}",
            event, agent_state.channel
        );
        if Some(event.channel()) != agent_state.channel {
            // This event is not for this module. It's not from a connection
            // this module is listening to. Ignore it.
            //
            // Yes, this implies that other modules could decide to eavesdrop on
            // messages intended for this module.
            continue;
        }

        // `content` is the body of the message from the remote end of the
        // connection.
        let content = event.content().unwrap().bytes();
        let kind = content[0];
        // Using the first byte of the message to determine the kind (or type)
        // of message is one of many possibilities. Do something different if
        // that's right for your game.
        //
        // If this were a real implementation, these hard coded numbers would be
        // represented by constants or maybe defined in separate schema.
        //
        // Whatever you choose to do, be sure to use a format/schema which is
        // understood by both ends of the communication.
        if kind == 0 {
            // Message type 0 is not implemented in this example. It's here to
            // show that there may be a message of kind 0, kind 1, kind 2, and
            // so on.
        } else if kind == 1 {
            writer.write_builder(|builder| {
                // Echo back the same content to the same channel (just an example).
                let content_offset = builder.create_vector(content);
                MessageToRemote::create(
                    builder,
                    &MessageToRemoteArgs {
                        channel: event.channel(),
                        content: Some(content_offset),
                    },
                )
            });
        } else if kind == 2 {
            let width = aspect.width;
            let height = aspect.height;
            let buffer = vec![0; 9];
            let mut msg = BufWriter::with_capacity(buffer.len(), buffer);
            msg.write_all(&[2u8]).unwrap();
            msg.write_all(&width.to_le_bytes()).unwrap();
            msg.write_all(&height.to_le_bytes()).unwrap();
            writer.write_builder(|builder| {
                let content_offset = builder.create_vector(msg.buffer());
                MessageToRemote::create(
                    builder,
                    &MessageToRemoteArgs {
                        channel: event.channel(),
                        content: Some(content_offset),
                    },
                )
            });
        } else if kind == 255 {
            port_ignore_writer.write_builder(|builder| {
                let user_id_offset = builder.create_string(&agent_state.user_id);
                PortIgnore::create(
                    builder,
                    &PortIgnoreArgs {
                        port: 9001,
                        user_id: Some(user_id_offset),
                    },
                )
            });
        } else {
            writer.write_builder(|builder| {
                // This is an example of sending a response informing the remote
                // end that a message was not understood.
                //
                // What to do here is very debatable. Some games may assume they
                // are being hacked or attacked and shutdown the connection with
                // no response. Others will try to 'just keep going' and ignore
                // unknown message types. And some may try to 'help the remote'
                // debug their work by sending a note, as is done here.
                //
                // Whatever you decide is right for your game should be
                // determine by the goals for that product (game). I.e. don't
                // automatically do this because it's in this example.
                let buffer = vec![0; 2];
                let mut msg = BufWriter::with_capacity(buffer.len(), buffer);
                // Here the value 255 is hard coded to mean: I didn't understand
                // this `kind` value.
                msg.write_all(&[255u8, kind]).unwrap();
                let content_offset = builder.create_vector(content);
                MessageToRemote::create(
                    builder,
                    &MessageToRemoteArgs {
                        channel: event.channel(),
                        content: Some(content_offset),
                    },
                )
            });
        }
    }
}
