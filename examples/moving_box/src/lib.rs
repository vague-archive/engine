//! Example using a few systems to move a box around.
//!
//! This example uses `system_once` to set up a displayable item and then two
//! systems to move and guide it. One system moves it in a given direction based
//! on the current game state. Another system looks for boundaries and changes
//! direction to avoid going off the screen. The result is a square shaped path
//! of movement.

use game_module_macro::{Resource, system, system_once};
use snapshot::{Deserialize, Serialize};
use void_public::{
    Aspect, ComponentId, EcsType, Engine, FrameConstants, Query, Resource, Transform, Vec2, Vec3,
    bundle, colors::palette, graphics::TextureRender, linalg,
};

/// Here are some directions which are shape may move in.
///
/// Exercises:
/// - (easy) Add more direction options.
/// - (intermediate) Change the direction options to a floating point value (not
///   an enum).
#[derive(Debug, Default, PartialEq, Deserialize, Serialize)]
enum Direction {
    North,
    East,
    #[default]
    South,
    West,
}

/// This `Resource` will be instantiated by the engine as a singleton. We can
/// read or write to the state in a `system` (or `system_once`).
///
/// Exercises:
/// - (easy) Add state for second object.
/// - (intermediate) Change this to allow for an arbitrary number of objects.
///
/// Note: There are better ways to track entities in the game. This is here for
/// teaching early concepts, it's not a 'best practices' example.
#[derive(Default, Resource)]
struct DemoState {
    direction: Direction,
}

/// A `const` value may be defined 'outside of the engine' i.e. not in a
/// Resource.
///
/// Exercises:
/// - (easy) Change this value and see what happens.
/// - (intermediate) Use different values for moving different things (assuming
///   you've added more moving things).
const MOVE_INCREMENT: f32 = 400.;

/// A `system_once` is run one time (only) in a game.
///
/// This is a good place to set up the game.
///
/// Exercises:
/// - (easy) Start the square in a different location.
/// - (intermediate) Spawn multiple things (each with their own transform).
#[system_once]
fn startup_system() {
    let transform = &Transform {
        position: linalg::Vec3::from_xyz(0., 0., 0.),
        scale: linalg::Vec2::new(Vec2::splat(20.)),
        ..Default::default()
    };
    Engine::spawn(bundle!(&TextureRender::default(), &palette::RED, transform));
}

/// A `system` runs once per frame.
///
/// This is a good place to update the game state.
///
/// Exercises:
/// - (easy) Add more direction options.
/// - (intermediate) Change the direction options to a floating point value (not
///   an enum).
#[system]
fn move_things(
    mut entities_with_transforms: Query<&mut Transform>,
    demo: &mut DemoState,
    frame_constants: &FrameConstants,
) {
    let (horizontal_scalar, vertical_scalar) = match demo.direction {
        Direction::East => (1., 0.),
        Direction::North => (0., -1.),
        Direction::South => (0., 1.0),
        Direction::West => (-1.0, 0.),
    };

    // This is where delta time is used (see [`../README.md`]).
    let move_amount = MOVE_INCREMENT * frame_constants.delta_time;

    let movement_vector = Vec3::new(horizontal_scalar, vertical_scalar, 0.) * move_amount;
    if movement_vector != Vec3::ZERO {
        entities_with_transforms.for_each(|transform| {
            transform.position += movement_vector;
        });
    }
}

/// A `system` runs once per frame.
///
/// Design systems which do just one thing well. Compose games with multiple
/// systems.
///
/// Exercises:
/// - (easy) This already works for multiple things moving! Reason out why.
/// - (intermediate) Use the `_aspect` value provided to reflect things off of
///   the very edges of the screen (rather than the arbitrary 'magic' values
///   used below).
#[system]
fn direction_system(
    mut entities_with_transforms: Query<&mut Transform>,
    _aspect: &Aspect,
    demo: &mut DemoState,
) {
    entities_with_transforms.for_each(|transform| {
        // Avoid using a hard-coded value like 140.0; see the "Exercises", above.
        let position = transform.position;
        if demo.direction == Direction::South && position.y > 140.0 {
            demo.direction = Direction::West;
        } else if demo.direction == Direction::West && position.x < -140.0 {
            demo.direction = Direction::North;
        } else if demo.direction == Direction::North && position.y < -140.0 {
            demo.direction = Direction::East;
        } else if demo.direction == Direction::East && position.x > 140.0 {
            demo.direction = Direction::South;
        }
    });
}

// This includes auto-generated C FFI code (saves you from writing it manually).
// Note: This file is generated by the `../build.rs` script. Take a peek if
// you're curious (or ignore this if you'd rather focus on just making your
// game).
include!(concat!(env!("OUT_DIR"), "/ffi.rs"));
